<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:math="http://www.w3.org/2005/xpath-functions/math"
    xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl"
    xmlns:tei="http://www.tei-c.org/ns/1.0"
    xmlns:egx="http://www.tei-c.org/ns/Examples"
    xmlns:xhtml="http://www.w3.org/1999/xhtml"
    xmlns:rng="http://relaxng.org/ns/structure/1.0"
    xmlns:sch="http://purl.oclc.org/dsdl/schematron"
    xmlns:local="no:where"
    xmlns:saxon="http://saxon.sf.net/"
    exclude-result-prefixes="xs math xd xhtml tei local rng sch egx saxon"
    version="3.0">
    <xd:doc scope="stylesheet">
        <xd:desc>
            <xd:p><xd:b>Created on:</xd:b> Dec 12, 2015, updated on Oct 6, 2017</xd:p>
            <xd:p><xd:b>Author:</xd:b> Johannes Kepper</xd:p>
            <xd:p>This XSL generates the website version of the MEI Guidelines, directly from a canonicalized ODD file.</xd:p>
        </xd:desc>
    </xd:doc>
    <xsl:output indent="true" method="html" saxon:suppress-indentation="egx:egXML tei:classes tei:content tei:list tei:item"/>
    <xsl:param name="version" select="'{{ site.baseurl }}/{{ page.version }}'" as="xs:string"/>
    <xsl:variable name="plain.version" select="'v' || substring-before(//tei:classSpec[@ident = ('att.meiversion','att.meiVersion')]//tei:defaultVal/text(),'.')" as="xs:string"/>
    <xd:doc scope="component">
        <xd:desc>
            <xd:p>
                $role describes the role of the output:
                'release' qualifies this as official release of MEI, using the version number provided.
                'custom' qualifies this as output of a customization of MEI
                'dev' qualifies this as development version of MEI, taken from the official repo.
                
                This param is used for a running header in PDF output.
            </xd:p>
        </xd:desc>
    </xd:doc>
    <xsl:param name="role" select="'release'" as="xs:string"/>
    
    <xd:doc scope="component">
        <xd:desc>
            <xd:p>
                $image.prefix is a general prefix prepended to all image paths generated by this stylesheet.
            </xd:p>
        </xd:desc>
    </xd:doc>
    <xsl:param name="image.prefix" as="xs:string">
        <xsl:value-of select="'{{ site.baseurl }}/'"/>
    </xsl:param>
    
    <xsl:param name="imprint.date" select="substring(string(current-date()),1,4)" as="xs:string"/>
    
    
    <!-- start of processing -->
    
    <xd:doc scope="component">
        <xd:desc>
            <xd:p>
                $supported.version contains reference strings for every supported MEI version. 
                The only use of this variable is to indicate a mismatch between it and the 
                $version variable in a message, but nothing else happens. 
                Nevertheless, if adjusted to newer versions of MEI, these version numbers 
                should be added below. 
            </xd:p>
        </xd:desc>
    </xd:doc>
    <xsl:variable name="supported.version" as="xs:string+">
        <xsl:value-of select="'3.0.0'"/>
        <!-- fill in further MEI version, for which this xsl has been adjusted -->
    </xsl:variable>
    
    <xsl:variable name="outPutFolder" select="'./' || $plain.version || '/'" as="xs:string"/>
    
    <xsl:variable name="mei.source" select="/" as="node()"/>
    
    <xsl:variable name="chapters" select="//tei:body//tei:div[@type = 'div1']" as="node()*"/>
    
    <xsl:variable name="all.chapters" as="node()*">
        <chapters>
            <xsl:for-each select="//tei:body/tei:div">
                <xsl:variable name="chapter1" select="." as="node()"/>
                <xsl:variable name="level1.index" select="position()" as="xs:integer"/>
                <chapter level="1" xml:id="{$chapter1/@xml:id}" number="{$level1.index}" head="{$chapter1/tei:head/text()}"/>
                
                <xsl:for-each select="child::tei:div">
                    <xsl:variable name="chapter2" select="." as="node()"/>
                    <xsl:variable name="level2.index" select="position()" as="xs:integer"/>
                    <chapter level="2" xml:id="{$chapter2/@xml:id}" number="{$level1.index}.{$level2.index}" head="{$chapter2/tei:head/text()}" parent.id="{$chapter1/@xml:id}"/>
                    
                    <xsl:for-each select="child::tei:div">
                        <xsl:variable name="chapter3" select="." as="node()"/>
                        <xsl:variable name="level3.index" select="position()" as="xs:integer"/>
                        <chapter level="3" xml:id="{$chapter3/@xml:id}" number="{$level1.index}.{$level2.index}.{$level3.index}" head="{$chapter3/tei:head/text()}" parent.id="{$chapter2/@xml:id}"/>
                        
                        <xsl:for-each select="child::tei:div">
                            <xsl:variable name="chapter4" select="." as="node()"/>
                            <xsl:variable name="level4.index" select="position()" as="xs:integer"/>
                            <chapter level="4" xml:id="{$chapter4/@xml:id}" number="{$level1.index}.{$level2.index}.{$level3.index}.{$level4.index}" head="{$chapter4/tei:head/text()}" parent.id="{$chapter3/@xml:id}"/>
                            
                            <xsl:for-each select="child::tei:div">
                                <xsl:variable name="chapter5" select="." as="node()"/>
                                <xsl:variable name="level5.index" select="position()" as="xs:integer"/>
                                <chapter level="5" xml:id="{$chapter5/@xml:id}" number="{$level1.index}.{$level2.index}.{$level3.index}.{$level4.index}.{$level5.index}" head="{$chapter5/tei:head/text()}" parent.id="{$chapter4/@xml:id}"/>
                            </xsl:for-each>
                            
                        </xsl:for-each>
                        
                    </xsl:for-each>
                    
                </xsl:for-each>
                
            </xsl:for-each>
        </chapters>
    </xsl:variable>
    
    <xsl:variable name="elements" as="node()*">
        <xsl:for-each select="//tei:elementSpec">
            <xsl:sort select="@ident" data-type="text"/>
            <xsl:sequence select="."/>
        </xsl:for-each>
    </xsl:variable>    
    <xsl:variable name="model.classes" as="node()*">
        <xsl:for-each select="//tei:classSpec[@type = 'model']">
            <xsl:sort select="@ident" data-type="text"/>
            <xsl:sequence select="."/>
        </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="att.classes" as="node()*">
        <xsl:for-each select="//tei:classSpec[@type = 'atts']">
            <xsl:sort select="@ident" data-type="text"/>
            <xsl:sequence select="."/>
        </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="data.types" as="node()*">
        <xsl:for-each select="//tei:macroSpec">
            <xsl:sort select="@ident" data-type="text"/>
            <xsl:sequence select="."/>
        </xsl:for-each>
    </xsl:variable>
    
    <xsl:template match="/">
        
        <xsl:message terminate="no" select="'INFO: Extracting Guidelines for publication from MEI source (version ' || $plain.version || ')'"/>
        
        <!--<xsl:if test="not($version = $supported.version)">
            <xsl:message terminate="no" select="'WARNING: This version of MEI is not officially supported. Please check the results carefully.'"/>
        </xsl:if>-->
        
        
        <!-- extract samples -->
        
        <xsl:for-each select=".//egx:egXML">
            <xsl:variable name="chapter" select="ancestor::tei:div[last()]/@xml:id"/>
            <xsl:variable name="pos" select="count(preceding::egx:egXML)"/>
            <xsl:variable name="posLink">
                <xsl:choose>
                    <xsl:when test="$pos lt 10"><xsl:value-of select="'00' || $pos"/></xsl:when>
                    <xsl:when test="$pos lt 100"><xsl:value-of select="'0' || $pos"/></xsl:when>
                    <xsl:otherwise><xsl:value-of select="$pos"/></xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:variable name="path" select="$outPutFolder || 'examples/' || $chapter || '/' || $chapter || '-sample' || $posLink || '.xml'"/>
            <xsl:variable name="example"><xsl:apply-templates select="." mode="preserveSpace"/></xsl:variable>
            <xsl:result-document href="{lower-case($path)}" omit-xml-declaration="yes"><xsl:apply-templates select="$example" mode="cleanup.example"/></xsl:result-document>
        </xsl:for-each>
        
        <!-- /extract samples -->
        
        <!-- extract subChapters -->
        <xsl:for-each select=".//tei:div[not(@type = 'div1')]">
            <xsl:apply-templates select="." mode="setupFileForMarkdown"/>
        </xsl:for-each>
        <!-- /extract subChapters -->
        
        <!-- extract desc -->
        
        <xsl:for-each select=".//tei:elementSpec">
            <xsl:variable name="element" select="."/>
            <xsl:variable name="path" select="$outPutFolder || 'desc/' || @ident || '.txt'" as="xs:string"/>
            <xsl:result-document href="{lower-case($path)}" omit-xml-declaration="yes"><xsl:value-of select="./tei:desc/text()"/></xsl:result-document>
            <xsl:for-each select=".//tei:attDef">
                <xsl:variable name="path" select="$outPutFolder || 'desc/' || $element/@ident || '/' || replace(@ident,':','---') || '.txt'" as="xs:string"/>
                <xsl:result-document href="{lower-case($path)}" omit-xml-declaration="yes"><xsl:value-of select="./tei:desc/text()"/></xsl:result-document>
            </xsl:for-each>
        </xsl:for-each>
        
        <xsl:for-each select=".//tei:classSpec">
            <xsl:variable name="class" select="."/>
            <xsl:variable name="path" select="$outPutFolder || 'desc/' || @ident || '.txt'" as="xs:string"/>
            <xsl:result-document href="{lower-case($path)}" omit-xml-declaration="yes"><xsl:value-of select="./tei:desc/text()"/></xsl:result-document>
            <xsl:for-each select=".//tei:attDef">
                <xsl:variable name="path" select="$outPutFolder || 'desc/' || $class/@ident || '/' || replace(@ident,':','---') || '.txt'" as="xs:string"/>
                <xsl:result-document href="{lower-case($path)}" omit-xml-declaration="yes"><xsl:value-of select="./tei:desc/text()"/></xsl:result-document>
            </xsl:for-each>
        </xsl:for-each>
        
        <xsl:for-each select=".//tei:macroSpec">
            <xsl:variable name="macro" select="."/>
            <xsl:variable name="path" select="$outPutFolder || 'desc/' || @ident || '.txt'" as="xs:string"/>
            <xsl:result-document href="{lower-case($path)}" omit-xml-declaration="yes"><xsl:value-of select="./tei:desc/text()"/></xsl:result-document>
            <xsl:for-each select=".//tei:attDef">
                <xsl:variable name="path" select="$outPutFolder || 'desc/' || $macro/@ident || '/' || replace(@ident,':','---') || '.txt'" as="xs:string"/>
                <xsl:result-document href="{lower-case($path)}" omit-xml-declaration="yes"><xsl:value-of select="./tei:desc/text()"/></xsl:result-document>
            </xsl:for-each>
        </xsl:for-each>
        
        <!-- /extract desc -->
        
        <!-- chapters -->
        <xsl:message select="'INFO: Resolving ' || count($chapters) || ' chapters.'"/>
        <xsl:variable name="chapterLinks" as="node()*">
            <xsl:for-each select="$chapters">
                <xsl:variable name="name" select="@xml:id"/>
                <xsl:variable name="heading" select="./tei:head[1]/text()"/>
                <xsl:variable name="headingNo" select="concat(position(),'.')"/>
                <a class="module" href="{$version}/guidelines/{lower-case($name)}.html">
                    <span class="no"><xsl:value-of select="$headingNo"/></span>
                    <span class="title"><xsl:value-of select="$heading"/></span></a>
            </xsl:for-each>
        </xsl:variable>
        
        <!-- elements -->
        <xsl:message select="'INFO: Resolving ' || count($elements) || ' elements.'"/>
        <xsl:variable name="elementLinks" as="node()*">
            <xsl:for-each select="$elements">
                <xsl:sort select="@ident" data-type="text"/>
                <xsl:variable name="name" select="@ident"/>
                <xsl:variable name="heading" select="$name"/>
                <a class="link_odd_elementSpec chip {substring($name,1,1)}" href="{$version}/elements/{lower-case($name)}.html"><xsl:value-of select="$heading"/></a>
            </xsl:for-each>
        </xsl:variable>
        
        <!-- model classes -->
        <xsl:message select="'INFO: Resolving ' || count($model.classes) || ' model classes.'"/>
        <xsl:variable name="modelLinks" as="node()*">
            <xsl:for-each select="$model.classes">
                <xsl:sort select="@ident" data-type="text"/>
                <xsl:variable name="name" select="@ident"/>
                <xsl:variable name="heading" select="$name"/>
                <a class="link_odd_classSpec chip {substring($name,7,1)}" href="{$version}/model-classes/{lower-case($name)}.html"><xsl:value-of select="$heading"/></a><br/>
            </xsl:for-each>
        </xsl:variable>
        
        <!-- attribute classes -->
        <xsl:message select="'INFO: Resolving ' || count($att.classes) || ' attribute classes.'"/>
        <xsl:variable name="attLinks" as="node()*">
            <xsl:for-each select="$att.classes">
                <xsl:sort select="@ident" data-type="text"/>
                <xsl:variable name="name" select="@ident"/>
                <xsl:variable name="heading" select="$name"/>
                <a class="link_odd chip {substring($name,5,1)}" href="{$version}/attribute-classes/{lower-case($name)}.html"><xsl:value-of select="$heading"/></a><br/>
            </xsl:for-each>
        </xsl:variable>
        
        <!-- data types and macros -->
        <xsl:message select="'INFO: Resolving ' || count($data.types) || ' data types.'"/>
        <xsl:variable name="dataLinks" as="node()*">
            <xsl:for-each select="$data.types">
                <xsl:variable name="name" select="@ident"/>
                <xsl:variable name="heading" select="$name"/>
                <a class="link_odd chip {if(starts-with($name,'macro')) then(substring($name,7,1)) else(substring($name,6,1))}" href="{$version}/data-types/{lower-case($name)}.html"><xsl:value-of select="$heading"/></a><br/>
            </xsl:for-each>
        </xsl:variable>
        
        <xsl:message select="'INFO: Building multiple HTML fragments for inclusion on music-encoding.org'"/>
         
        <!-- chapter overview -->
        <xsl:result-document href="{$outPutFolder}guidelines.md" omit-xml-declaration="true">---
layout: sidebar
sidebar: s1
title: "Guidelines"
version: "<xsl:value-of select="$plain.version"/>"
<xsl:call-template name="generateCategoryOverview">
    <xsl:with-param name="items" select="$chapterLinks" as="node()*"/>
    <xsl:with-param name="mode" select="'chapters'" as="xs:string"/>
</xsl:call-template>
<xsl:call-template name="processItems">
    <xsl:with-param name="items" select="$chapters" as="node()*"/>
    <xsl:with-param name="itemLinks" select="$chapterLinks" as="node()*"/>
    <xsl:with-param name="mode" select="'chapters'" as="xs:string"/>
</xsl:call-template>
        </xsl:result-document>
        
            <!-- elements overview -->
        <xsl:result-document href="{$outPutFolder}elements.md" omit-xml-declaration="true">---
layout: sidebar
sidebar: s1
title: "Elements"
version: "<xsl:value-of select="$plain.version"/>"
---
<xsl:call-template name="generateCategoryOverview">
    <xsl:with-param name="items" select="$elementLinks" as="node()*"/>
    <xsl:with-param name="mode" select="'elements'" as="xs:string"/>
</xsl:call-template>
<xsl:call-template name="processItems">
    <xsl:with-param name="items" select="$elements" as="node()*"/>
    <xsl:with-param name="itemLinks" select="$elementLinks" as="node()*"/>
    <xsl:with-param name="mode" select="'elements'" as="xs:string"/>
</xsl:call-template>
        </xsl:result-document>
            
            <!-- model overview -->
        <xsl:result-document href="{$outPutFolder}model-classes.md" omit-xml-declaration="true">---
layout: sidebar
sidebar: s1
title: "Model Classes"
version: "<xsl:value-of select="$plain.version"/>"
---
<xsl:call-template name="generateCategoryOverview">
    <xsl:with-param name="items" select="$modelLinks" as="node()*"/>
    <xsl:with-param name="mode" select="'models'" as="xs:string"/>
</xsl:call-template>
<xsl:call-template name="processItems">
    <xsl:with-param name="items" select="$model.classes" as="node()*"/>
    <xsl:with-param name="itemLinks" select="$modelLinks" as="node()*"/>
    <xsl:with-param name="mode" select="'models'" as="xs:string"/>
</xsl:call-template>
        </xsl:result-document>
            
            <!-- attribute overview -->
        <xsl:result-document href="{$outPutFolder}attribute-classes.md" omit-xml-declaration="true">---
layout: sidebar
sidebar: s1
title: "Attribute Classes"
version: "<xsl:value-of select="$plain.version"/>"
---
<xsl:call-template name="generateCategoryOverview">
    <xsl:with-param name="items" select="$attLinks" as="node()*"/>
    <xsl:with-param name="mode" select="'atts'" as="xs:string"/>
</xsl:call-template>
<xsl:call-template name="processItems">
    <xsl:with-param name="items" select="$att.classes" as="node()*"/>
    <xsl:with-param name="itemLinks" select="$attLinks" as="node()*"/>
    <xsl:with-param name="mode" select="'atts'" as="xs:string"/>
</xsl:call-template>
        </xsl:result-document>
            
        <!-- data type overview -->
        <xsl:result-document href="{$outPutFolder}data-types.md" omit-xml-declaration="true">---
layout: sidebar
sidebar: s1
title: "Data Types"
version: "<xsl:value-of select="$plain.version"/>"
---
<xsl:call-template name="generateCategoryOverview">
    <xsl:with-param name="items" select="$dataLinks" as="node()*"/>
    <xsl:with-param name="mode" select="'dataMacros'" as="xs:string"/>
</xsl:call-template>
<xsl:call-template name="processItems">
    <xsl:with-param name="items" select="$data.types" as="node()*"/>
    <xsl:with-param name="itemLinks" select="$dataLinks" as="node()*"/>
    <xsl:with-param name="mode" select="'dataMacros'" as="xs:string"/>
</xsl:call-template>   
        </xsl:result-document>
        
    </xsl:template>
    
    
    <!-- generate overview pages for each category -->
    <xsl:template name="generateCategoryOverview" as="node()">
        <xsl:param name="items" as="node()*"/>
        <xsl:param name="mode" as="xs:string"/>
        <div>
            
            <xsl:choose>
                <xsl:when test="$mode = 'chapters'">
                    <h3 class="widget-title">Table of Contents</h3>
                    <div class="textwidget">
                        <ul class="guidelinesList">
                            <xsl:for-each select="$items">
                                <li><xsl:copy-of select="."/></li>
                            </xsl:for-each>
                        </ul>
                    </div>
                </xsl:when>
                <xsl:when test="$mode = ('elements','models','atts')">
                    <h3 class="widget-title">
                        <xsl:choose>
                            <xsl:when test="$mode = 'elements'">MEI Elements</xsl:when>
                            <xsl:when test="$mode = 'models'">MEI Model Classes</xsl:when>
                            <xsl:when test="$mode = 'atts'">MEI Attribute Classes</xsl:when>
                        </xsl:choose>
                    </h3>
                    <div class="textwidget">
                        <xsl:for-each select="(97 to 122)">
                            <xsl:variable name="key" select="codepoints-to-string(.)"/>
                            <xsl:variable name="links" select="$items/descendant-or-self::a[ends-with(@class,$key)]"/>
                            
                            <xsl:if test="count($links) gt 0">
                                <div class="sortedInitials well {$key}">
                                    <h3><xsl:value-of select="$key"/></h3>
                                    <xsl:copy-of select="$links"/>
                                </div>
                            </xsl:if>
                        </xsl:for-each>
                    </div>
                </xsl:when>
                <xsl:when test="$mode = 'dataMacros'">
                    <h3 class="widget-title">MEI Data Types and Macros</h3>
                    <div class="textwidget">
                        <xsl:for-each select="(65 to 90)">
                            <xsl:variable name="key" select="codepoints-to-string(.)"/>
                            <xsl:variable name="links" select="$items/descendant-or-self::a[ends-with(@class,$key)]"/>
                            
                            <xsl:if test="count($links) gt 0">
                                <div class="sortedInitials well {$key}">
                                    <h3><xsl:value-of select="lower-case($key)"/></h3>
                                    <xsl:copy-of select="$links"/>
                                </div>
                            </xsl:if>
                            
                        </xsl:for-each>
                        
                        <xsl:variable name="macros" select="$items/descendant-or-self::a[starts-with(./text(),'macro.')]"/>
                        <xsl:if test="count($macros) gt 0">
                            <div class="sortedInitials well macros">
                                <h3>Macros</h3>
                                <xsl:copy-of select="$macros"/>
                            </div>
                        </xsl:if>
                    </div>
                </xsl:when>
            </xsl:choose>
                            
        </div>
        
    </xsl:template>
    
    <!-- get primary sidebar navigation -->
    <!--<xsl:template name="getPrimarySideNav" as="node()*">
        <header class="entry-header">
            <h1 class="entry-title">
                MEI Guidelines <small>Version <xsl:value-of select="$version"/></small>
            </h1>				
        </header>
        <div class="textwidget">
            <ul class="guidelinesList">
                <li><a class="guidelines_mainLink" href="{$version}/chapters">MEI Guidelines</a></li>
                <li><a class="guidelines_mainLink" href="{$version}/elements">Elements</a></li>
                <li><a class="guidelines_mainLink" href="{$version}/atts">Attributes</a></li>
                <li><a class="guidelines_mainLink" href="{$version}/models">Model Classes</a></li>
                <li><a class="guidelines_mainLink" href="{$version}/data">Data Types</a></li>
            </ul>
        </div>
    </xsl:template>-->
    
    <!-- frame for processing each individual item -->
    <xsl:template name="processItems" as="node()*">
        <xsl:param name="items" as="node()*"/>
        <xsl:param name="itemLinks" as="node()*"/>
        <xsl:param name="mode" as="xs:string"/>
        <xsl:if test="not(count($items) = count($itemLinks/descendant-or-self::a))">
            <xsl:message terminate="no" select="'ERROR: The number of items (' || count($items) || ') does not match the number of generated TOC entries (' || count($itemLinks/descendant-or-self::a) || ') for ' || $mode || '. Please check!.'"/>
        </xsl:if>
        
        <xsl:for-each select="$items">
            <xsl:variable name="name" select="if($mode = 'chapters') then(@xml:id) else(@ident)" as="xs:string"/>
            
            <xsl:variable name="result" as="node()+">
                <xsl:choose>
                    <xsl:when test="$mode = 'chapters'">
                        <xsl:apply-templates select="." mode="markdown"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:apply-templates select="."/>
                    </xsl:otherwise>
                </xsl:choose>
                
            </xsl:variable>
            
            <xsl:variable name="folderName" as="xs:string">
                <xsl:choose>
                    <xsl:when test="$mode = 'chapters'">
                        <xsl:value-of select="'guidelines'"/>
                    </xsl:when>
                    <xsl:when test="$mode = 'elements'">
                        <xsl:value-of select="'elements'"/>
                    </xsl:when>
                    <xsl:when test="$mode = 'atts'">
                        <xsl:value-of select="'attribute-classes'"/>
                    </xsl:when>
                    <xsl:when test="$mode = 'models'">
                        <xsl:value-of select="'model-classes'"/>
                    </xsl:when>
                    <xsl:when test="$mode = 'dataMacros'">
                        <xsl:value-of select="'data-types'"/>
                    </xsl:when>
                </xsl:choose>
            </xsl:variable>
            
            <xsl:variable name="chapterPrefix" as="xs:string?">
                <xsl:if test="$mode = 'chapters'">
                    <xsl:variable name="chapterElem" select="$all.chapters//*:chapter[@xml:id = $name]" as="node()"/>
                    <xsl:value-of select="local:padNumber2($chapterElem/@number) || '-'"/>
                </xsl:if>
            </xsl:variable>
            
            <xsl:result-document href="{$outPutFolder || $folderName || '/' || lower-case($chapterPrefix) || lower-case($name)}.md" omit-xml-declaration="true">---
layout: sidebar
sidebar: s1
version: "<xsl:value-of select="$plain.version"/>"
title: "<xsl:value-of select="if($mode = 'chapters') then($all.chapters//*:chapter[@xml:id = $name]/@head) else($name)"/>"
<xsl:if test="$mode = 'chapters'">sectionid: "<xsl:value-of select="$name"/>"</xsl:if>
---

<xsl:sequence select="$result"/>
                
            </xsl:result-document>        
                
        </xsl:for-each>
    </xsl:template>
    
    <!-- resolve chapters -->
    <xsl:template match="tei:div[@type = 'div1']">
        <xsl:variable name="chapter" select="." as="node()"/>
        <xsl:variable name="my.index" select="string(count(preceding-sibling::tei:div[@type = 'div1']) + 1)" as="xs:string"/>
        
        <section class="div1">
            <xsl:apply-templates select="node()" mode="#current"/>
        </section>
    </xsl:template>
    
    <xsl:template match="tei:div[not(@type = 'div1')]">
        
        <xsl:variable name="chapter" select="." as="node()"/>
        
        <xsl:if test="not($chapter/@xml:id)">
            <xsl:message terminate="no" select="'ERROR: chapter inside ' || ancestor::tei:div[@xml:id][1]/@xml:id || ' has no @xml:id. Please fix!'"/>
        </xsl:if>
        
        <div>
            <xsl:apply-templates select="node()" mode="#current"/>
        </div>
    </xsl:template>
    
    <xsl:template match="tei:body//tei:div[not(@type = 'div1')]" mode="setupFileForMarkdown">
        
        <xsl:variable name="relevant.outputFolder" select="$outPutFolder || 'guidelines/'" as="xs:string"/>
        
        <xsl:variable name="chapter" select="." as="node()"/>
        <xsl:variable name="chapterNumElem" select="$all.chapters//*:chapter[@xml:id = $chapter/@xml:id]" as="node()?"/>
        
        <xsl:variable name="chapter.index" select="local:padNumber2(tokenize($chapterNumElem/@number,'\.')[last()])" as="xs:string"/>
        <xsl:variable name="chapter.path" select="$chapter.index || '-' || $chapter/@xml:id || '.md'" as="xs:string"/>
        
        <xsl:variable name="level1.chapter" select="$chapterNumElem/preceding-sibling::*:chapter[@level = '1'][1]" as="node()"/>
        <xsl:variable name="level1.index" select="local:padNumber2($level1.chapter/@number)" as="xs:string"/>
        <xsl:variable name="level1.path" select="$level1.index || '-' || $level1.chapter/@xml:id || '/'" as="xs:string"/>
        
        <xsl:variable name="path" as="xs:string">
            <xsl:choose>
                <xsl:when test="$chapterNumElem/@level = '1'">
                    <xsl:message terminate="yes" select="'This should not have happened'"/>
                </xsl:when>
                <xsl:when test="$chapterNumElem/@level = '2'">
                    <xsl:value-of select="$relevant.outputFolder || $level1.path || $chapter.path"/>
                </xsl:when>
                <xsl:when test="$chapterNumElem/@level = '3'">
                    <xsl:variable name="level2.chapter" select="$chapterNumElem/preceding-sibling::*:chapter[@level = '2'][1]" as="node()"/>
                    <xsl:variable name="level2.index" select="local:padNumber2(tokenize($level2.chapter/@number,'\.')[2])" as="xs:string"/>
                    <xsl:variable name="level2.path" select="$level2.index || '-' || $level2.chapter/@xml:id || '/'" as="xs:string"/>
                    
                    <xsl:value-of select="$relevant.outputFolder || $level1.path || $level2.path || $chapter.path"/>
                </xsl:when>
                <xsl:when test="$chapterNumElem/@level = '4'">
                    <xsl:variable name="level2.chapter" select="$chapterNumElem/preceding-sibling::*:chapter[@level = '2'][1]" as="node()"/>
                    <xsl:variable name="level2.index" select="local:padNumber2(tokenize($level2.chapter/@number,'\.')[2])" as="xs:string"/>
                    <xsl:variable name="level2.path" select="$level2.index || '-' || $level2.chapter/@xml:id || '/'" as="xs:string"/>
                    
                    <xsl:variable name="level3.chapter" select="$chapterNumElem/preceding-sibling::*:chapter[@level = '3'][1]" as="node()"/>
                    <xsl:variable name="level3.index" select="local:padNumber2(tokenize($level3.chapter/@number,'\.')[3])" as="xs:string"/>
                    <xsl:variable name="level3.path" select="$level3.index || '-' || $level3.chapter/@xml:id || '/'" as="xs:string"/>
                    
                    <xsl:value-of select="$relevant.outputFolder || $level1.path || $level2.path || $level3.path || $chapter.path"/>
                </xsl:when>
                <xsl:when test="$chapterNumElem/@level = '5'">
                    <xsl:variable name="level2.chapter" select="$chapterNumElem/preceding-sibling::*:chapter[@level = '2'][1]" as="node()"/>
                    <xsl:variable name="level2.index" select="local:padNumber2(tokenize($level2.chapter/@number,'\.')[2])" as="xs:string"/>
                    <xsl:variable name="level2.path" select="$level2.index || '-' || $level2.chapter/@xml:id || '/'" as="xs:string"/>
                    
                    <xsl:variable name="level3.chapter" select="$chapterNumElem/preceding-sibling::*:chapter[@level = '3'][1]" as="node()"/>
                    <xsl:variable name="level3.index" select="local:padNumber2(tokenize($level3.chapter/@number,'\.')[3])" as="xs:string"/>
                    <xsl:variable name="level3.path" select="$level3.index || '-' || $level3.chapter/@xml:id || '/'" as="xs:string"/>
                    
                    <xsl:variable name="level4.chapter" select="$chapterNumElem/preceding-sibling::*:chapter[@level = '4'][1]" as="node()"/>
                    <xsl:variable name="level4.index" select="local:padNumber2(tokenize($level4.chapter/@number,'\.')[4])" as="xs:string"/>
                    <xsl:variable name="level4.path" select="$level4.index || '-' || $level4.chapter/@xml:id || '/'" as="xs:string"/>
                    
                    <xsl:value-of select="$relevant.outputFolder || $level1.path || $level2.path || $level3.path || $level4.path || $chapter.path"/>
                </xsl:when>
                <xsl:when test="$chapterNumElem/@level = '6'">
                    <xsl:variable name="level2.chapter" select="$chapterNumElem/preceding-sibling::*:chapter[@level = '2'][1]" as="node()"/>
                    <xsl:variable name="level2.index" select="local:padNumber2(tokenize($level2.chapter/@number,'\.')[2])" as="xs:string"/>
                    <xsl:variable name="level2.path" select="$level2.index || '-' || $level2.chapter/@xml:id || '/'" as="xs:string"/>
                    
                    <xsl:variable name="level3.chapter" select="$chapterNumElem/preceding-sibling::*:chapter[@level = '3'][1]" as="node()"/>
                    <xsl:variable name="level3.index" select="local:padNumber2(tokenize($level3.chapter/@number,'\.')[3])" as="xs:string"/>
                    <xsl:variable name="level3.path" select="$level3.index || '-' || $level3.chapter/@xml:id || '/'" as="xs:string"/>
                    
                    <xsl:variable name="level4.chapter" select="$chapterNumElem/preceding-sibling::*:chapter[@level = '4'][1]" as="node()"/>
                    <xsl:variable name="level4.index" select="local:padNumber2(tokenize($level4.chapter/@number,'\.')[4])" as="xs:string"/>
                    <xsl:variable name="level4.path" select="$level4.index || '-' || $level4.chapter/@xml:id || '/'" as="xs:string"/>
                    
                    <xsl:variable name="level5.chapter" select="$chapterNumElem/preceding-sibling::*:chapter[@level = '5'][1]" as="node()"/>
                    <xsl:variable name="level5.index" select="local:padNumber2(tokenize($level5.chapter/@number,'\.')[5])" as="xs:string"/>
                    <xsl:variable name="level5.path" select="$level5.index || '-' || $level5.chapter/@xml:id || '/'" as="xs:string"/>
                    
                    <xsl:value-of select="$relevant.outputFolder || $level1.path || $level2.path || $level3.path || $level4.path || $level5.path || $chapter.path"/>
                </xsl:when>
            </xsl:choose>
        </xsl:variable>
        
        <xsl:result-document href="{lower-case($path)}" method="html" omit-xml-declaration="yes">---
sectionid: <xsl:value-of select="$chapter/@xml:id"/>
title: "<xsl:value-of select="$chapterNumElem/@head"/>"
version: "<xsl:value-of select="$plain.version"/>"
---

<xsl:apply-templates select="node()" mode="markdown"/>

        </xsl:result-document>
            
    </xsl:template>
    
    <xsl:template match="tei:div[@type = 'div1']" mode="markdown">
        <xsl:apply-templates select="node()" mode="#current"/>
    </xsl:template>
    
    <xsl:template match="tei:div[not(@type = 'div1')]" mode="markdown"/>
    
    <xsl:template match="tei:div/text()" mode="markdown"/>
    <xsl:template match="comment()" priority="1" mode="markdown"/>
    
    <xsl:template match="tei:head">
        
        <xsl:choose>
            <xsl:when test="parent::tei:div">
                <xsl:variable name="div.id" select="parent::tei:div/@xml:id" as="xs:string?"/>
                <xsl:choose>
                    <xsl:when test="ancestor::tei:front">
                        <h1>
                            <span class="head"><xsl:value-of select="text()"/></span>
                        </h1>
                    </xsl:when>
                    <xsl:when test="ancestor::tei:back">
                        <xsl:variable name="level" select="string(number(substring-after(parent::tei:div/@type,'div')) + 1)"/>
                        <xsl:element name="h{$level}">
                            <xsl:attribute name="id" select="$div.id"/>
                            <span class="headingNumber"></span>
                            <span class="head"><xsl:value-of select="text()"/></span>
                        </xsl:element>
                    </xsl:when>
                    <xsl:when test="exists($div.id)">
                        <xsl:variable name="tocInfo" select="$all.chapters/*[@xml:id = $div.id]" as="node()?"/>
                        
                        <xsl:if test="not($tocInfo)">
                            <xsl:message terminate="yes" select="'ERROR: Unable to find chapter ' || $div.id || ' in $all.chapters'"/>
                        </xsl:if>
                        
                        <xsl:element name="h{$tocInfo/@level}">
                            <xsl:attribute name="id" select="$div.id"/>
                            <span class="headingNumber"><xsl:value-of select="$tocInfo/@number"/> </span>
                            <span class="head"><xsl:value-of select="text()"/></span>
                        </xsl:element>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:message select="'WARNING: Heading _' || text() || '_ has no @xml:id, and cannot be referenced therefore. Numbering will be incorrect as well. Please fix!'"/>
                        <h4>
                            <span class="head"><xsl:value-of select="text()"/></span>
                        </h4>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:when test="parent::tei:figure and parent::tei:figure/tei:graphic">
                <figcaption class="caption">Figure <xsl:value-of select="count(preceding::tei:figure[./tei:graphic]) + 1"/>. <xsl:apply-templates select="node()" mode="#current"/></figcaption>
            </xsl:when>
            <xsl:when test="parent::tei:figure and parent::tei:figure/egx:egXML">
                <figcaption class="caption">Listing <xsl:value-of select="count(preceding::tei:figure[./egx:egXML]) + 1"/>. <xsl:apply-templates select="node()" mode="#current"/></figcaption>
            </xsl:when>
            <xsl:when test="parent::tei:figure">
                <xsl:message terminate="no" select="'WARNING: Not rendering tei:head in tei:figure, because there is no apparent element to which it belongs. Content: ' || text()"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:message terminate="no" select="'ERROR: This should not have happened'"/>
            </xsl:otherwise>
        </xsl:choose>
        
    </xsl:template>
    
    <xsl:template match="tei:head" mode="markdown">
        
        <xsl:choose>
            <xsl:when test="parent::tei:div">
                <xsl:variable name="div.id" select="parent::tei:div/@xml:id" as="xs:string?"/>
                <xsl:choose>
                    <xsl:when test="ancestor::tei:front">
                        # <xsl:value-of select="text()"/>
                        
                    </xsl:when>
                    <xsl:when test="ancestor::tei:back">
                        <xsl:variable name="level" select="number(substring-after(parent::tei:div/@type,'div')) + 1"/>
                        <xsl:element name="h{$level}">
                            <xsl:attribute name="id" select="$div.id"/>
                            <span class="headingNumber"></span>
                            <span class="head"><xsl:value-of select="text()"/></span>
                        </xsl:element>
                    </xsl:when>
                    <xsl:when test="exists($div.id)">
                        <xsl:variable name="tocInfo" select="$all.chapters/*[@xml:id = $div.id]" as="node()?"/>
                        
                        <xsl:if test="not($tocInfo)">
                            <xsl:message terminate="yes" select="'ERROR: Unable to find chapter ' || $div.id || ' in $all.chapters'"/>
                        </xsl:if>
                        
                        <!-- automatically inserted by jekyll -->
                        <!--<xsl:element name="h{$tocInfo/@level}">
                            <xsl:attribute name="id" select="$div.id"/>
                            <span class="headingNumber"><xsl:value-of select="$tocInfo/@number"/> </span>
                            <span class="head"><xsl:value-of select="text()"/></span>
                        </xsl:element>-->
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:message select="'WARNING: Heading _' || text() || '_ has no @xml:id, and cannot be referenced therefore. Numbering will be incorrect as well. Please fix!'"/>
                        <h4>
                            <span class="head"><xsl:value-of select="text()"/></span>
                        </h4>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:when test="parent::tei:figure and parent::tei:figure/tei:graphic">
                <figcaption class="figure-caption">Figure <xsl:value-of select="count(preceding::tei:figure[./tei:graphic]) + 1"/>. <xsl:apply-templates select="node()" mode="#current"/></figcaption>
            </xsl:when>
            <xsl:when test="parent::tei:figure and parent::tei:figure/egx:egXML">
                <figcaption class="figure-caption">Listing <xsl:value-of select="count(preceding::tei:figure[./egx:egXML]) + 1"/>. <xsl:apply-templates select="node()" mode="#current"/></figcaption>
            </xsl:when>
            <xsl:when test="parent::tei:figure">
                <xsl:message terminate="no" select="'WARNING: Not rendering tei:head in tei:figure, because there is no apparent element to which it belongs. Content: ' || text()"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:message terminate="no" select="'ERROR: This should not have happened'"/>
            </xsl:otherwise>
        </xsl:choose>
        
    </xsl:template>
    
    <xsl:template match="tei:p">
        <p>
            <xsl:apply-templates select="node()" mode="#current"/>
        </p>
    </xsl:template>
    
    <xsl:template match="tei:p" mode="markdown"><xsl:apply-templates select="node()" mode="#current"/><xsl:value-of select="'&#xa; &#xa;'"/></xsl:template>
    
    <xsl:template match="tei:list">
        <xsl:choose>
            <xsl:when test="@type = ('bulleted','simple')">
                <xsl:if test="child::tei:head">
                    <strong class="listHead"><xsl:apply-templates select="child::tei:head/node()"/></strong>
                </xsl:if>
                <ul>
                    <xsl:for-each select="tei:item">
                        <li class="item">
                            <xsl:apply-templates select="node()" mode="#current"/>
                        </li>
                    </xsl:for-each>
                </ul>
            </xsl:when>
            <xsl:when test="@type = 'ordered'">
                <xsl:if test="child::tei:head">
                    <strong class="listHead"><xsl:apply-templates select="child::tei:head/node()"/></strong>
                </xsl:if>
                <ol>
                    <xsl:for-each select="tei:item">
                        <li class="item">
                            <xsl:apply-templates select="node()" mode="#current"/>
                        </li>
                    </xsl:for-each>
                </ol>
            </xsl:when>
            <xsl:when test="@type = 'gloss'">
                <dl>
                    <xsl:for-each select="tei:label">
                        <dt><span><xsl:apply-templates select="node()" mode="#current"/></span></dt>
                        <dd><xsl:apply-templates select="following-sibling::tei:item[1]/node()" mode="#current"/></dd>
                    </xsl:for-each>
                </dl>
            </xsl:when>
            <xsl:otherwise>
                <xsl:if test="child::tei:head">
                    <strong class="listHead"><xsl:apply-templates select="child::tei:head/node()"/></strong>
                </xsl:if>
                <ul>
                    <xsl:for-each select="tei:item">
                        <li class="item">
                            <xsl:apply-templates select="node()" mode="#current"/>
                        </li>
                    </xsl:for-each>
                </ul>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    
    <xsl:template match="tei:list" mode="markdown">
        <xsl:choose>
            <xsl:when test="@type = ('bulleted','simple')">
                <xsl:if test="child::tei:head">**<xsl:apply-templates select="child::tei:head/node()"/>**</xsl:if>
                <xsl:for-each select="tei:item"><xsl:variable name="content" as="xs:string*"><xsl:apply-templates select="node()" mode="#current"/></xsl:variable><xsl:choose><xsl:when test="position() gt 1">&#xa;- </xsl:when><xsl:otherwise>- </xsl:otherwise></xsl:choose><xsl:value-of select="normalize-space(string-join($content,' '))"/></xsl:for-each>                
            </xsl:when>
            <xsl:when test="@type = 'ordered'">
                <xsl:if test="child::tei:head">**<xsl:apply-templates select="child::tei:head/node()"/>**</xsl:if>
                <xsl:for-each select="tei:item"><xsl:variable name="content" as="xs:string*"><xsl:apply-templates select="node()" mode="#current"/></xsl:variable><xsl:choose><xsl:when test="position() gt 1">&#xa;. </xsl:when><xsl:otherwise>. </xsl:otherwise></xsl:choose><xsl:value-of select="normalize-space(string-join($content,' '))"/></xsl:for-each>
            </xsl:when>
            <xsl:when test="@type = 'gloss'">
                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th>Value</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <xsl:for-each select="tei:label">
                            <tr>
                                <td><xsl:apply-templates select="node()"/></td>
                                <td><xsl:apply-templates select="following-sibling::tei:item[1]/node()"/></td>
                            </tr>
                        </xsl:for-each>
                    </tbody>
                </table>
                
            </xsl:when>
            <xsl:otherwise>
                <xsl:if test="child::tei:head">**<xsl:apply-templates select="child::tei:head/node()"/>**</xsl:if>
                <xsl:for-each select="tei:item"><xsl:variable name="content" as="xs:string"><xsl:apply-templates select="node()" mode="#current"/></xsl:variable><xsl:choose><xsl:when test="position() gt 1">&#xa;- </xsl:when><xsl:otherwise>- </xsl:otherwise></xsl:choose><xsl:value-of select="normalize-space(string-join($content,' '))"/></xsl:for-each>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    
    <xsl:template match="tei:gi">
        <xsl:variable name="text" select="string(text())" as="xs:string"/>
        <xsl:choose>
            <xsl:when test="$text = $elements/@ident">
                <a class="link_odd_elementSpec" href="{$version}/elements/{$text}.html"><xsl:value-of select="$text"/></a>
            </xsl:when>
            <xsl:otherwise>
                <xsl:message select="'WARNING: Unable to retrieve definition of element ' || $text || '. No link created. Please check spelling…'"/>
                <xsl:next-match/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    
    <xsl:template match="tei:gi" mode="markdown">
        <xsl:variable name="text" select="string(text())" as="xs:string"/>
        <xsl:variable name="link">
            <xsl:call-template name="linkToElement">
                <xsl:with-param name="elem" select="$text"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:choose>
            <xsl:when test="$text = $elements/@ident">{% include link elem="<xsl:value-of select="$text"/>" %}</xsl:when>
            <xsl:otherwise>
                <xsl:message select="'WARNING: Unable to retrieve definition of element ' || $text || '. No link created. Please check spelling…'"/>
                <xsl:next-match/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    
    <xsl:template match="tei:ident[@type = 'class']">
        <xsl:variable name="text" select="string(text())" as="xs:string"/>
        <xsl:choose>
            <xsl:when test="$text = //tei:classSpec/@ident">
                <xsl:variable name="link">
                    <xsl:choose>
                        <xsl:when test="starts-with($text,'model.')">
                            <xsl:call-template name="linkToModel">
                                <xsl:with-param name="model" select="$text"/>
                            </xsl:call-template>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:call-template name="linkToAttribute">
                                <xsl:with-param name="att" select="$text"/>
                            </xsl:call-template>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:variable>
                <a class="link_odd" href="{$link}"><xsl:value-of select="$text"/></a>
            </xsl:when>
            <xsl:otherwise>
                <xsl:message terminate="no" select="'ERROR: Unable to identify class ' || $text || ' from tei:ident element. No link created.'"/>
                <span class="ident">
                    <xsl:apply-templates select="node()" mode="#current"/>
                </span>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    
    <xsl:template match="tei:ident[@type = 'class']" mode="markdown">
        <xsl:variable name="text" select="string(text())" as="xs:string"/>
        <xsl:variable name="link">
            <xsl:choose>
                <xsl:when test="starts-with($text,'model.')">
                    <xsl:call-template name="linkToModel">
                        <xsl:with-param name="model" select="$text"/>
                    </xsl:call-template>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:call-template name="linkToAttribute">
                        <xsl:with-param name="att" select="$text"/>
                    </xsl:call-template>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:choose>
            <xsl:when test="$text = //tei:classSpec/@ident">{% include link att-class="<xsl:value-of select="$text"/>" %}</xsl:when>
            <xsl:otherwise>
                <xsl:message terminate="no" select="'ERROR: Unable to identify class ' || $text || ' from tei:ident element. No link created.'"/>
                <span class="ident">
                    <xsl:apply-templates select="node()" mode="#current"/>
                </span>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    
    <xsl:template match="tei:specList">
        <ul class="specList">
            <xsl:for-each select="tei:specDesc">
                <xsl:variable name="key" select="@key" as="xs:string"/>
                <xsl:variable name="specDesc" select="." as="node()"/>
                <xsl:variable name="spec" select="if(count(//tei:*[@ident = $key and not(local-name() = ('schemaSpec','valItem'))]) = 1) 
                    then(//tei:*[@ident = $key and not(local-name() = ('schemaSpec','valItem'))]) 
                    else(//tei:*[@ident = $key and not(local-name() = ('schemaSpec','valItem','attDef'))])" as="node()*"/>
                <xsl:if test="count($spec) gt 1">
                    <xsl:message select="'INFO: problem with @ident=' || $key || ', which is found ' || count($spec) || ' times.'"/>
                </xsl:if>
                <xsl:if test="count($spec) = 0">
                    <xsl:message select="'INFO: problem with @ident=' || $key || ', which cannot be found with the current exclusions.'"/>
                </xsl:if>
                <li>
                    <xsl:choose>
                        <xsl:when test="not($specDesc/@atts)">
                            <span class="specList-{local-name($spec)}"><xsl:value-of select="$key"/></span>
                            <xsl:apply-templates select="$spec/tei:desc/node()"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <table class="specDesc">
                                <tbody>
                                    <xsl:for-each select="tokenize(normalize-space($specDesc/@atts),' ')">
                                        <xsl:variable name="current.att" select="." as="xs:string"/>
                                        <tr>
                                            <td class="Attribute">
                                                <span class="att"><xsl:value-of select="$current.att"/></span>
                                            </td>
                                            <td>
                                                <xsl:choose>
                                                    <xsl:when test="$spec//tei:attDef[@ident = $current.att]">
                                                        <xsl:apply-templates select="$spec//tei:attDef[@ident = $current.att]/tei:desc/node()" mode="#current"/>
                                                    </xsl:when>
                                                    <xsl:otherwise>
                                                        <xsl:variable name="attributes" select="local:getAttributes($spec)" as="node()*"/>
                                                        <xsl:apply-templates select="$attributes/descendant-or-self::div[span[@class='attribute']/text() = '@' || $current.att]/span[@class='attributeDesc']/node()" mode="#current"/>
                                                    </xsl:otherwise>
                                                </xsl:choose>
                                            </td>
                                        </tr>
                                    </xsl:for-each>
                                </tbody>
                            </table>
                        </xsl:otherwise>
                    </xsl:choose>
                </li>
            </xsl:for-each>
        </ul>
    </xsl:template>
    
    <!-- This template isn't called from specList, but only for individual specDescs -> should be merged -->
    <xsl:template match="tei:specDesc">
        <div class="specList">
            <xsl:variable name="key" select="@key" as="xs:string"/>
            <xsl:variable name="spec" select="//tei:*[@ident = $key]" as="node()?"/>
            <xsl:if test="not($spec)">
                <xsl:message select="."></xsl:message>
                <xsl:message terminate="yes" select="$key"/>
            </xsl:if>
            <xsl:variable name="specDesc" select="." as="node()"/>
            <xsl:choose>
                <xsl:when test="not($specDesc/@atts)">
                    <span class="specList-{local-name($spec)}"><xsl:value-of select="$key"/></span>
                    <xsl:apply-templates select="$spec/tei:desc/node()"/>
                </xsl:when>
                <xsl:otherwise>
                    <table class="specDesc">
                        <tbody>
                            <xsl:for-each select="tokenize(normalize-space($specDesc/@atts),' ')">
                                <xsl:variable name="current.att" select="." as="xs:string"/>
                                <tr>
                                    <td class="Attribute">
                                        <span class="att"><xsl:value-of select="$current.att"/></span>
                                    </td>
                                    <td>
                                        <xsl:choose>
                                            <xsl:when test="$spec//tei:attDef[@ident = $current.att]">
                                                <xsl:apply-templates select="$spec//tei:attDef[@ident = $current.att]/tei:desc/node()" mode="#current"/>
                                            </xsl:when>
                                            <xsl:otherwise>
                                                <xsl:variable name="attributes" select="local:getAttributes($spec)" as="node()*"/>
                                                <xsl:apply-templates select="$attributes//div[span[@class='attribute']/text() = '@' || $current.att]/span[@class='attributeDesc']/node()" mode="#current"/>
                                            </xsl:otherwise>
                                        </xsl:choose>
                                    </td>
                                </tr>
                            </xsl:for-each>
                        </tbody>
                    </table>
                </xsl:otherwise>
            </xsl:choose>
        </div>
    </xsl:template>
    
    <xsl:template match="tei:specList" mode="markdown"><xsl:apply-templates select="node()" mode="#current"/>
<xsl:text>
</xsl:text>    
    </xsl:template>
    
    <xsl:template match="tei:specDesc" mode="markdown">
        <xsl:choose>
            <xsl:when test="not(@atts)">{% include desc elem="<xsl:value-of select="@key"/>" %}</xsl:when>
            <xsl:otherwise>
                <xsl:variable name="key" select="@key" as="xs:string"/>
                <xsl:variable name="spec" select="//tei:*[@ident = $key and not(local-name() = ('schemaSpec','valItem','attDef'))]" as="node()?"/>
                <xsl:if test="not($spec)">
                    <xsl:message select="."></xsl:message>
                    <xsl:message terminate="yes" select="$key"/>
                </xsl:if>
                <xsl:variable name="specDesc" select="." as="node()"/>
                <xsl:variable name="refs" as="xs:string*">
                    <xsl:for-each select="tokenize(normalize-space(@atts),' ')">
                        <xsl:variable name="current.att" select="." as="xs:string"/>
                        <xsl:choose>
                            <!-- attributes directly defined at the element -->
                            <xsl:when test="$spec//tei:attDef[@ident = $current.att]">
                                <xsl:variable name="name" select="replace($current.att,':','---')" as="xs:string"/>
                                <xsl:value-of select="$key || '/' || $name"/>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:variable name="attributes" select="local:getAttributes($spec)" as="node()*"/>
                                <xsl:variable name="name" select="$attributes/descendant-or-self::*:div[*:span[@class='attribute']/*:strong/text() = '@' || $current.att]//*:span[@class = 'attributeClasses']/*:a/text()" as="xs:string?"/>
                                
                                <xsl:choose>
                                    <xsl:when test="string-length($name) gt 0">
                                        <xsl:value-of select="$name || '/' || replace($current.att,':','---')"/>
                                    </xsl:when>
                                    <xsl:otherwise>
                                        <xsl:message select="'  [WARNING] Unable to retrieve attribute ' || $current.att || ' from ' || $key"/>
                                    </xsl:otherwise>
                                </xsl:choose>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:for-each>    
                </xsl:variable>
                <xsl:if test="count($refs) gt 0">{% include desc atts="<xsl:value-of select="string-join($refs,' ')"/>" %}</xsl:if>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    
    <xsl:template match="tei:ptr">
        
        <xsl:variable name="chapter.id" select="replace(@target,'#','')" as="xs:string"/>
        <xsl:variable name="tocInfo" select="$all.chapters/*[@xml:id = $chapter.id]" as="node()?"/>
        <xsl:choose>
            <xsl:when test="not($tocInfo)">
                <xsl:message terminate="no" select="'ERROR: Could not retrieve chapter with @xml:id ' || $chapter.id || ' (referenced from a //tei:ptr/@target). Please check!'"/>
                <span class="wrong_ptr"> <xsl:value-of select="@target"/> </span>
            </xsl:when>
            <xsl:otherwise>
                
                <xsl:variable name="base.id" select="if($tocInfo/@level = '1') then($tocInfo/@xml:id) else($tocInfo/preceding-sibling::*[@level = '1'][1]/@xml:id)" as="xs:string"/>
                
                <a class="link_ptr" title="{$tocInfo/@head}" href="{$version}/guidelines/{$base.id || (if(not($tocInfo/@level = '1')) then('#' || $chapter.id) else())}"><xsl:value-of select="$tocInfo/@number || ' ' || $tocInfo/@head"/></a>        
                    
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    
    <xsl:template match="tei:ptr" mode="markdown">
        
        <xsl:variable name="chapter.id" select="replace(@target,'#','')" as="xs:string"/>
        <xsl:variable name="tocInfo" select="$all.chapters/*[@xml:id = $chapter.id]" as="node()?"/>
        <xsl:choose>
            <xsl:when test="not($tocInfo)">
                <xsl:message terminate="no" select="'ERROR: Could not retrieve chapter with @xml:id ' || $chapter.id || ' (referenced from a //tei:ptr/@target). Please check!'"/>
                <span class="wrong_ptr"> <xsl:value-of select="@target"/> </span>
            </xsl:when>
            <xsl:otherwise>{% include link id="<xsl:value-of select="$chapter.id"/>" %}</xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    
    
    <xsl:template match="tei:ref">
        <xsl:choose>
            <xsl:when test="starts-with(@target,'#')">
                <xsl:variable name="chapter.id" select="replace(@target,'#','')" as="xs:string"/>
                <xsl:variable name="chapter" select="//tei:div[@xml:id = $chapter.id]" as="node()?"/>
                <xsl:choose>
                    <xsl:when test="exists($chapter)">
                        <xsl:variable name="head" select="string($chapter/tei:head[1]/text())" as="xs:string"/>
                        <xsl:variable name="base.id" select="$chapter/ancestor-or-self::tei:div[@type = 'div1']/@xml:id" as="xs:string"/>
                        
                        <a class="link_ref" title="{$head}" href="{$version}/guidelines/{$base.id || (if($base.id = $chapter.id) then() else('#' || $chapter.id))}"><xsl:apply-templates select="node()" mode="#current"/></a>
                        
                    </xsl:when>
                    <xsl:otherwise>
                        <span class="ref" data-target="{$chapter.id}"><xsl:apply-templates select="node()" mode="#current"/></span>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <a class="link_ref" href="{@target}"><xsl:apply-templates select="node()" mode="#current"/></a>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    
    <xsl:template match="tei:ref" mode="markdown">
        <xsl:choose>
            <xsl:when test="starts-with(@target,'#')">
                <xsl:variable name="chapter.id" select="replace(@target,'#','')" as="xs:string"/>
                <xsl:variable name="chapter" select="//tei:div[@xml:id = $chapter.id]" as="node()?"/>
                <xsl:choose>
                    <xsl:when test="exists($chapter)">
                        <xsl:variable name="head" select="string($chapter/tei:head[1]/text())" as="xs:string"/>
                        <xsl:variable name="base.id" select="$chapter/ancestor-or-self::tei:div[@type = 'div1']/@xml:id" as="xs:string"/>
                        <xsl:variable name="url" select="$version || '/guidelines/' || $base.id || '.html' || (if($base.id = $chapter.id) then() else('#' || $chapter.id))"/>{% include link id="<xsl:value-of select="$chapter.id"/>" %}</xsl:when>
                    <xsl:otherwise>
                        <span class="ref" data-target="{$chapter.id}"><xsl:apply-templates select="node()" mode="#current"/></span>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>[<xsl:apply-templates select="node()" mode="#current"/>](<xsl:value-of select="@target"/>){:.link_ref}</xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    
    
    <xsl:template match="tei:foreign">
        <span class="foreign"><xsl:apply-templates select="node()" mode="#current"/></span>
    </xsl:template>
    
    <xsl:template match="tei:foreign" mode="markdown">*<xsl:apply-templates select="node()" mode="#current"/>*</xsl:template>
    
    <xsl:template match="comment()" mode="markdown" priority="2"/>
    
    <xsl:template match="tei:att">
        <span class="att"><xsl:apply-templates select="node()" mode="#current"/></span>
    </xsl:template>
    
    <xsl:template match="tei:att" mode="markdown">**@<xsl:apply-templates select="node()" mode="#current"/>**</xsl:template>
    
    <!-- todo: this should be done with CSS! -->
    <xsl:template match="tei:soCalled">
        <xsl:value-of select="'‘'"/><xsl:apply-templates select="node()" mode="#current"/><xsl:value-of select="'’'"/>
    </xsl:template>
    
    <xsl:template match="tei:soCalled" mode="markdown">‘<xsl:apply-templates select="node()" mode="#current"/>’</xsl:template>
    
    <xsl:template match="tei:title">
        <span class="titlem"><xsl:apply-templates select="node()" mode="#current"/></span>
    </xsl:template>
    
    <xsl:template match="tei:title" mode="markdown">*<xsl:apply-templates select="node()" mode="#current"/>*</xsl:template>
    
    <xsl:template match="tei:bibl">
        <span class="bibl"><xsl:apply-templates select="node()" mode="#current"/></span>
    </xsl:template>
    
    <xsl:template match="tei:bibl" mode="markdown">
        <span class="bibl"><xsl:apply-templates select="node()" mode="#current"/></span>
    </xsl:template>
    
    <xsl:template match="tei:term">
        <span class="term"><xsl:apply-templates select="node()" mode="#current"/></span>
    </xsl:template>
    
    <xsl:template match="tei:term" mode="markdown"><xsl:apply-templates select="node()" mode="#current"/></xsl:template>
    
    <xsl:template match="tei:mentioned">
        <span class="mentioned"><xsl:apply-templates select="node()" mode="#current"/></span>
    </xsl:template>
    
    <xsl:template match="tei:mentioned" mode="markdown">
        <span class="mentioned"><xsl:apply-templates select="node()" mode="#current"/></span>
    </xsl:template>
    
    <xsl:template match="tei:emph">
        <em class="mentioned"><xsl:apply-templates select="node()" mode="#current"/></em>
    </xsl:template>
    
    <xsl:template match="tei:emph" mode="markdown">*<xsl:apply-templates select="node()" mode="#current"/>*</xsl:template>
    
    <xsl:template match="tei:exemplum">
        <xsl:apply-templates select="node()" mode="#current"/>
    </xsl:template>
    
    <xsl:template match="tei:exemplum" mode="markdown">
        <xsl:apply-templates select="node()" mode="#current"/>
    </xsl:template>
    
    <xsl:template match="egx:egXML">
        <div xml:space="preserve" class="pre egXML_{if(@valid='false') then('invalid') else if(@valid='feasible') then('feasible') else('valid')}">
<xsl:apply-templates select="node()" mode="preserveSpace"/>
        </div>
    </xsl:template>
    
    <xsl:template match="egx:egXML" mode="markdown">
        <xsl:variable name="chapter" select="ancestor::tei:div[last()]/@xml:id"/>
        <xsl:variable name="pos" select="count(preceding::egx:egXML)"/>
        <xsl:variable name="posLink">
            <xsl:choose>
                <xsl:when test="$pos lt 10"><xsl:value-of select="'00' || $pos"/></xsl:when>
                <xsl:when test="$pos lt 100"><xsl:value-of select="'0' || $pos"/></xsl:when>
                <xsl:otherwise><xsl:value-of select="$pos"/></xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="path" select="$chapter || '/' || $chapter || '-sample' || $posLink || '.xml'"/>{% include mei example="<xsl:value-of select="$path"/>" valid="<xsl:value-of select="@valid"/>" %}
    </xsl:template>
        
    <xsl:template match="tei:table">
        <xsl:message select="'WARNING: There is still a tei:table, which is probably incorrect. If not, improve this stylesheet.'"/>
        <!--<table>
            
        </table>-->
    </xsl:template>
    
    <xsl:template match="tei:table" mode="markdown"/>
    
    <!-- todo -->
    <!--<xsl:template match="tei:row">
        
    </xsl:template>
    
    <xsl:template match="tei:cell">
        
    </xsl:template>-->
    
    <xsl:template match="tei:val">
        <span class="val"><xsl:apply-templates select="node()" mode="#current"/></span>
    </xsl:template>
    
    <xsl:template match="tei:val" mode="markdown">*<xsl:apply-templates select="node()" mode="#current"/>*</xsl:template>
    
    <xsl:template match="tei:formula">
        <span class="formula"><xsl:apply-templates select="node()" mode="#current"/></span>
    </xsl:template>
    
    <xsl:template match="tei:formula" mode="markdown">*<xsl:apply-templates select="node()" mode="#current"/>*</xsl:template>
    
    <xsl:template match="tei:figure">
        <figure class="figure">
            <xsl:apply-templates select="tei:graphic | egx:egXML" mode="#current"/>
            <xsl:apply-templates select="tei:head" mode="#current"/>
        </figure>
    </xsl:template>
    
    <xsl:template match="tei:figure" mode="markdown">
        
        <figure class="figure">
            <xsl:apply-templates select="tei:graphic | egx:egXML" mode="#current"/>
            <xsl:apply-templates select="tei:head" mode="#current"/>
        </figure>
        
    </xsl:template>
    
    <xsl:template match="tei:graphic">
        <img src="{$image.prefix||@url}" class="graphic"/>
    </xsl:template>
    
    <xsl:template match="tei:graphic" mode="markdown">
        <img src="{$image.prefix||@url}" class="img-responsive"/>
    </xsl:template>
    
    <!-- ___________________________ -->
    
    
    <!-- resolve elements -->
    <xsl:template match="tei:elementSpec">
        <xsl:variable name="elementSpec" select="." as="node()"/>
        <div class="elementSpec">
            <h3 id="{@ident}">&lt;<xsl:value-of select="@ident"/>&gt;</h3>
            <table class="wovenodd">
                <tr>
                    <td colspan="2" class="wovenodd-col2">
                        <xsl:value-of select="$elementSpec/tei:desc/text()"/>
                    </td>
                </tr>
                <tr>
                    <td class="wovenodd-col1"><strong>Module</strong></td>
                    <td class="wovenodd-col2"><xsl:value-of select="$elementSpec/@module"/></td>
                </tr>
                <tr>
                    <td class="wovenodd-col1"><strong>Attributes</strong></td>
                    <td class="wovenodd-col2">
                        
                        <!-- docu: identify all relevant attributes -->
                        <xsl:variable name="attributes" as="node()*">
                            
                            <!-- docu: get attributes specified at the current element -->
                            <xsl:for-each select="$elementSpec//tei:attDef">
                                <xsl:variable name="current.att" select="." as="node()"/>
                                
                                <xsl:sequence select="local:resolveAttDef($current.att,$elementSpec/@ident)"/>
                                
                            </xsl:for-each>
                            
                            <!-- get attributes derived from attribute classes -->
                            <xsl:sequence select="local:getAttributes($elementSpec)"/>
                        </xsl:variable>
                        <xsl:variable name="attribute.names" select="distinct-values($attributes/descendant-or-self::*:span[@class = 'attribute']/*:strong/string(text()))" as="xs:string*"/>
                        
                        <xsl:if test="count($attributes) ne count($attribute.names)">
                            <xsl:message select="'DEBUG: element ' || $elementSpec/@ident || ' has ' || count($attributes) || ' attributes: ' || string-join($attribute.names,', ')"/>
                            <xsl:message select="' '"></xsl:message>
                        </xsl:if>
                        
                        <xsl:if test="count($attributes) gt 0">
                            <table class="table table-striped">
                                <thead>
                                    <tr>
                                        <th></th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <xsl:for-each select="$attribute.names">
                                        <xsl:sort select="." data-type="text"/>
                                        <xsl:variable name="current.att" select="." as="xs:string"/>
                                        <xsl:if test="count($attributes/descendant-or-self::div[span[@class='attribute']/strong/text() = $current.att]) gt 1">
                                            <xsl:message select="'INFO: attribute ' || $current.att || ' specified multiple times on element ' || $elementSpec/@ident"/>
                                        </xsl:if>
                                        <tr>
                                            <td>
                                            <xsl:sequence select="($attributes/descendant-or-self::div[span[@class='attribute']/strong/text() = $current.att])[1]"/>
                                            </td>
                                        </tr>
                                    </xsl:for-each>
                                </tbody>
                            </table>
                        </xsl:if>
                    </td>
                </tr>
                <tr>
                    <td class="wovenodd-col1"><strong>Member of</strong></td>
                    <td class="wovenodd-col2">
                        <div class="parent">
                            <xsl:for-each select="$elementSpec//tei:memberOf[starts-with(@key,'model.')]">
                                <xsl:value-of select="if(position() gt 1) then(' ') else('')"/><a class="link_odd_classSpec" href="{$version}/model-classes/{@key}.html"><xsl:value-of select="@key"/></a>
                            </xsl:for-each>
                        </div>
                    </td>
                </tr>
                <tr>
                    <td class="wovenodd-col1"><strong>Contained by</strong></td>
                    <td class="wovenodd-col2">
                        <div class="parent">
                            <div class="specChildren">
                                
                                <xsl:variable name="direct.parents" select="$elements/descendant-or-self::tei:elementSpec[.//tei:content//rng:ref[@name = $elementSpec/@ident]]" as="node()*"/>
                                <xsl:variable name="class.parents" select="local:getParents($model.classes/descendant-or-self::tei:classSpec[@ident = $elementSpec//tei:memberOf[starts-with(@key,'model.')]/@key])" as="node()*"/>
                                <xsl:variable name="macro.parents" select="local:getParents($data.types/descendant-or-self::tei:macroSpec[.//tei:content//rng:ref[@name = $elementSpec/@ident]])" as="node()*"/>
                                
                                <xsl:variable name="parents" select="$direct.parents | $class.parents | $macro.parents" as="node()*"/>
                                
                                <xsl:for-each select="distinct-values($parents/descendant-or-self::tei:elementSpec/@module)">
                                    <xsl:sort select="count($mei.source//tei:moduleSpec[@ident = current()]/preceding::tei:moduleSpec)" data-type="number"/>
                                    <xsl:variable name="current.module" select="." as="xs:string"/>
                                    <xsl:variable name="relevant.element.names" select="distinct-values($parents/descendant-or-self::tei:elementSpec[@module = $current.module]/@ident)" as="xs:string*"/>
                                    <div class="specChild">
                                        <span class="specChildModule"><xsl:value-of select="$current.module"/></span>
                                        <span class="specChildElements">
                                            <xsl:for-each select="$relevant.element.names">
                                                <xsl:variable name="current.elem" select="." as="xs:string"/>
                                                <xsl:value-of select="if(position() gt 1) then(' ') else('')"/><a class="link_odd_elementSpec" href="{$version}/elements/{$current.elem}.html"><xsl:value-of select="$current.elem"/></a>
                                            </xsl:for-each>
                                        </span>
                                    </div>
                                </xsl:for-each>
                            </div>
                        </div>
                    </td>
                </tr>
                <tr>
                    <td class="wovenodd-col1"><strong>May contain</strong></td>
                    <td class="wovenodd-col2">
                        <xsl:variable name="direct.childs" select="$elements/descendant-or-self::tei:elementSpec[@ident = $elementSpec//tei:content//rng:ref[not(starts-with(@name,'model.'))]/@name]" as="node()*"/>
                        <xsl:variable name="class.childs" as="node()*">
                            
                            <xsl:for-each select="$elementSpec//tei:content//rng:ref[starts-with(@name,'model.')]">
                                <xsl:variable name="modelClass.name" select="@name" as="xs:string"/>
                                <xsl:sequence select="local:getChilds($modelClass.name)"/>
                            </xsl:for-each>
                        </xsl:variable>
                        <xsl:variable name="macro.childs" as="node()*">
                            <xsl:for-each select="$elementSpec//tei:content//rng:ref[starts-with(@name,'macro.')]">
                                <xsl:variable name="macroSpec.name" select="@name" as="xs:string"/>
                                <xsl:variable name="macroSpec" select="$data.types/descendant-or-self::tei:macroSpec[@ident = $macroSpec.name]" as="node()"/>
                                <xsl:sequence select="$elements/descendant-or-self::tei:elementSpec[@ident = $macroSpec//tei:content//rng:ref/@name]"/>    
                            </xsl:for-each>
                        </xsl:variable>
                        
                        <xsl:variable name="childs" select="$direct.childs | $class.childs | $macro.childs" as="node()*"/>
                        <!--<xsl:message select="'INFO: ' || $elementSpec/@ident || ' has ' || count($direct.childs) || ' direct and ' || count($class.childs) ||' class childs.'"/>-->
                        <xsl:choose>
                            <xsl:when test="(count($childs) gt 0) or $elementSpec//tei:content//rng:text">
                                <div class="specChildren">
                                    <xsl:if test="$elementSpec//tei:content//rng:text">
                                        <div class="specChild">
                                            <span class="specChildModule">Text</span>
                                            <span class="specChildElements"></span>
                                        </div>
                                    </xsl:if>
                                    <xsl:for-each select="distinct-values($childs/descendant-or-self::tei:elementSpec/@module)">
                                        <xsl:sort select="count($mei.source//tei:moduleSpec[@ident = current()]/preceding::tei:moduleSpec)" data-type="number"/>
                                        <xsl:variable name="current.module" select="." as="xs:string"/>
                                        <xsl:variable name="relevant.element.names" select="distinct-values($childs/descendant-or-self::tei:elementSpec[@module = $current.module]/@ident)" as="xs:string*"/>
                                        <div class="specChild">
                                            <span class="specChildModule"><xsl:value-of select="$current.module"/></span>
                                            <span class="specChildElements">
                                                <xsl:for-each select="$relevant.element.names">
                                                    <xsl:variable name="current.elem" select="." as="xs:string"/>
                                                    <xsl:value-of select="if(position() gt 1) then(' ') else('')"/><a class="link_odd_elementSpec" href="{$version}/elements/{$current.elem}.html"><xsl:value-of select="$current.elem"/></a>
                                                </xsl:for-each>
                                            </span>
                                        </div>
                                    </xsl:for-each>
                                </div>
                            </xsl:when>
                            <xsl:otherwise>
                                <div class="specChild">
                                    <span class="specChildModule">Empty</span>
                                    <span class="specChildElements"></span>
                                </div> 
                            </xsl:otherwise>
                        </xsl:choose>
                    </td>
                </tr>
                <tr>
                    <td class="wovenodd-col1"><strong>Declaration</strong></td>
                    <td class="wovenodd-col2">
                        <xsl:variable name="codeBlock">
                            <xsl:apply-templates select="$elementSpec/(tei:classes | tei:content)" mode="preserveSpace"><xsl:with-param name="getODD" tunnel="yes" select="true()"/></xsl:apply-templates>
                        </xsl:variable>
                        <div class="code" xml:space="preserve" data-lang="ODD"><code><xsl:apply-templates select="$codeBlock" mode="removeSpaceInCode"/></code></div>
                    </td>
                </tr>
                <xsl:if test="$elementSpec/tei:exemplum">
                    <tr>
                        <td class="wovenodd-col1"><strong>Examples</strong></td>
                        <td class="wovenodd-col2">
                            <xsl:for-each select="$elementSpec/tei:exemplum">
                                <div class="code" xml:space="preserve"><code><xsl:apply-templates select="child::egx:egXML/child::*" mode="preserveSpace"><xsl:with-param name="getODD" tunnel="yes" select="true()"/></xsl:apply-templates></code></div>
                            </xsl:for-each>
                        </td>
                    </tr>
                </xsl:if>
                <xsl:if test="$elementSpec/tei:remarks">
                    <tr>
                        <td class="wovenodd-col1"><strong>Remarks</strong></td>
                        <td class="wovenodd-col2">
                            <p><xsl:apply-templates select="$elementSpec/tei:remarks/tei:p/node()"/></p>
                        </td>
                    </tr>
                </xsl:if>
                <xsl:for-each select="$elementSpec//tei:constraintSpec">
                    <tr>
                        <td class="wovenodd-col1"><strong>Constraint</strong></td>
                        <td class="wovenodd-col2">
                            <div>
                                <xsl:for-each select=".//sch:assert">
                                    <div class="schematronText"><xsl:value-of select="normalize-space(string-join(.//text(),' '))"/></div>
                                </xsl:for-each>
                            </div>
                            <div class="code" xml:space="preserve" data-lang="Schematron"><code><xsl:apply-templates select=".//sch:rule" mode="preserveSpace"/></code></div>
                        </td>
                    </tr>
                </xsl:for-each>
            </table>
        </div>
    </xsl:template>
    
    <xsl:function name="local:getAttributes" as="node()*">
        <xsl:param name="elem" as="node()"/>
        
        <xsl:variable name="classes" select="$elem//tei:memberOf[starts-with(@key,'att.')]/@key" as="xs:string*"/>
        
        <xsl:for-each select="$classes">
            <xsl:variable name="current.class.id" select="." as="xs:string"/>
            <xsl:variable name="current.class" select="$mei.source//tei:classSpec[@ident = $current.class.id]" as="node()"/>
            
            <xsl:for-each select="$current.class//tei:attDef">
                <xsl:variable name="current.att" select="." as="node()"/>
                
                <xsl:sequence select="local:resolveAttDef($current.att,$current.class.id)"/>
            </xsl:for-each>
            
            <xsl:sequence select="local:getAttributes($current.class)"/>
            
        </xsl:for-each>
        
    </xsl:function>
    
    <xsl:function name="local:resolveAttDef" as="node()">
        <xsl:param name="current.att" as="node()"/>
        <xsl:param name="current.class.id" as="xs:string?"/>
        <xsl:variable name="usage" select="if($current.att/@usage = 'opt') then('optional') else if($current.att/@usage = 'req') then('required') else($current.att/@usage)" as="xs:string?"/>
        
        <div class="attributeDef">
            <span class="attribute"><strong>@<xsl:value-of select="$current.att/@ident"/></strong></span>
            <xsl:if test="$usage"><span class="attributeUsage">(<xsl:value-of select="$usage"/>)</span></xsl:if>
            <span class="attributeDesc"><xsl:apply-templates select="$current.att/tei:desc/node()"/></span>
            <xsl:choose>
                <xsl:when test="$current.att/tei:valList">
                    Allowed values are:
                    <xsl:for-each select="$current.att/tei:valList/tei:valItem">
                        <xsl:if test="position() gt 1">, </xsl:if> "<span style="font-weight: 500;"><xsl:value-of select="@ident"/></span>" <xsl:if test="tei:desc"> <i>(<xsl:value-of select="tei:desc/text()"/>)</i></xsl:if>
                    </xsl:for-each>
                    <xsl:if test="$current.att/tei:valList/@type = 'semi' and $current.att/tei:dataType/rng:data[@type = 'NMTOKEN']">
                        and custom <i>NMToken</i>
                    </xsl:if>
                </xsl:when>
                <xsl:when test="$current.att/tei:datatype[rng:ref]">
                    <xsl:variable name="dt" select="$current.att/tei:datatype" as="node()"/>
                    <xsl:choose>
                        <xsl:when test="$dt/@maxOccurs = '1'">
                            Value conforms to <a class="link_odd_classSpec" href="{$version}/data-types/{lower-case($dt/rng:ref/@name)}.html"><xsl:value-of select="$dt/rng:ref/@name"/></a>.
                        </xsl:when>
                        <xsl:when test="$dt/@maxOccurs = '2'">
                            One or two values from <a class="link_odd_classSpec" href="{$version}/data-types/{lower-case($dt/rng:ref/@name)}.html"><xsl:value-of select="$dt/rng:ref/@name"/></a>, separated by a space.
                        </xsl:when>
                        <xsl:when test="$dt/@maxOccurs = 'unbounded'">
                            One or more values from <a class="link_odd_classSpec" href="{$version}/data-types/{lower-case($dt/rng:ref/@name)}.html"><xsl:value-of select="$dt/rng:ref/@name"/></a>, separated by spaces.
                        </xsl:when>
                        <xsl:when test="not($dt/@maxOccurs) and not($dt/@minOccurs)">
                            Value conforms to <a class="link_odd_classSpec" href="{$version}/data-types/{lower-case($dt/rng:ref/@name)}.html"><xsl:value-of select="$dt/rng:ref/@name"/></a>.
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:message select="'ERROR: Unable to resolve the following datatype on attribute ' || $current.att/@ident"/>
                            <xsl:message terminate="yes" select="$dt"/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:when test="$current.att/tei:datatype[rng:data]">
                    <xsl:variable name="dt" select="$current.att/tei:datatype" as="node()"/>
                    <xsl:choose>
                        <xsl:when test="$dt/@maxOccurs = '1'">
                            Value of datatype <span style="font-weight: 500;"><xsl:sequence select="local:resolveData($dt//rng:data[1])"/></span>.
                        </xsl:when>
                        <xsl:when test="$dt/@maxOccurs = '2'">
                            One or two values of datatype <span style="font-weight: 500;"><xsl:sequence select="local:resolveData($dt//rng:data[1])"/></span>, separated by a space.
                        </xsl:when>
                        <xsl:when test="$dt/@maxOccurs = 'unbounded'">
                            One or more values of datatype <span style="font-weight: 500;"><xsl:sequence select="local:resolveData($dt//rng:data[1])"/></span>, separated by spaces.
                        </xsl:when>
                        <xsl:when test="count($dt/child::rng:ref) = 1 and $dt/child::rng:ref/@type = 'string'">
                            Value is plain text.
                        </xsl:when>
                        <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'string'">
                            Value is plain text.
                        </xsl:when>
                        <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'ID'">
                            Value is a valid <a target="_blank" href="https://www.w3.org/TR/xml-id/">xml:id</a>.
                        </xsl:when>
                        <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'decimal'">
                            Value is a decimal number.
                        </xsl:when>
                        <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'integer'">
                            Value is an integer.
                        </xsl:when>
                        <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'positiveInteger'">
                            Value is a positive integer.
                        </xsl:when>
                        <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'nonNegativeInteger'">
                            Value is a positive integer, including 0.
                        </xsl:when>
                        <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'language'">
                            Value is a <a target="_blank" href="https://www.w3.org/TR/xmlschema11-2/#language">language</a>.
                        </xsl:when>
                        <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'token'">
                            Value is a <a target="_blank" href="https://www.w3.org/TR/xmlschema11-2/#token">token</a>.
                        </xsl:when>
                        <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'NMTOKEN'">
                            Value is a <a target="_blank" href="https://www.w3.org/TR/xmlschema11-2/#NMTOKEN">NMTOKEN</a>.
                        </xsl:when>
                        <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'duration'">
                            Value is an <a target="_blank" href="https://www.w3.org/TR/xmlschema11-2/#duration">ISO duration</a>.
                        </xsl:when>
                        <xsl:when test="count($dt/child::rng:data) = 1 and $dt/child::rng:data/@type = 'token' and $dt/child::rng:data/child::rng:param[@name='pattern']">
                            Value conforms to the pattern "<span style="font-weight: 500;"><xsl:value-of select="$dt//rng:param[@name='pattern']/text()"/></span>".
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:message select="'ERROR: Unable to resolve the following datatype on attribute ' || $current.att/@ident"/>
                            <xsl:message terminate="yes" select="$dt"/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:when test="$current.att/tei:datatype[rng:list]">
                    <xsl:variable name="dt" select="$current.att/tei:datatype" as="node()"/>
                    <xsl:choose>
                        <xsl:when test="$dt/rng:list/rng:oneOrMore/rng:data[@type='token']/rng:param[@name='pattern']">
                            One or more values conforming to the pattern "<span style="font-weight: 500;"><xsl:value-of select="$dt//rng:param[@name='pattern']/text()"/></span>".
                        </xsl:when>
                        <xsl:when test="count($dt/rng:list/rng:oneOrMore/rng:data) = 2">
                            One or more values, each consisting of a sequence of <span style="font-weight: 500;"><xsl:sequence select="local:resolveData($dt//rng:data[1])"/></span> and <span style="font-weight: 500;"><xsl:sequence select="local:resolveData($dt//rng:data[2])"/></span> sub-values.
                        </xsl:when>
                        <xsl:when test="count($dt/rng:list/rng:oneOrMore/rng:data) = 1">
                            One or more of <span style="font-weight: 500;"><xsl:sequence select="local:resolveData($dt//rng:data[1])"/></span>.
                        </xsl:when>
                        <xsl:when test="$dt/rng:list/rng:oneOrMore/rng:data[following-sibling::rng:ref]">
                            One or more values, each consisting of a sequence of a <span style="font-weight: 500;"><xsl:sequence select="local:resolveData($dt//rng:data)"/></span> part, followed by a <a class="link_odd_classSpec" href="{$version}/data-types/{lower-case($dt//rng:ref/@name)}.html"><xsl:value-of select="$dt//rng:ref/@name"/></a>.
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:message select="'ERROR: Unable to resolve the following datatype on attribute ' || $current.att/@ident"/>
                            <xsl:message terminate="yes" select="$dt"/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:when test="$current.att/tei:datatype[rng:choice]">
                    <xsl:variable name="dt" select="$current.att/tei:datatype" as="node()"/>
                    <xsl:choose>
                        <xsl:when test="$dt/rng:choice[count(child::rng:data) = 2]">
                            Value must either conform to <span style="font-weight: 500;"><xsl:sequence select="local:resolveData($dt//rng:data[1])"/></span> or <span style="font-weight: 500;"><xsl:sequence select="local:resolveData($dt//rng:data[2])"/></span>.                            
                        </xsl:when>
                        <xsl:when test="$dt/rng:choice[count(child::*) = 1]">
                            Value must conform to <span style="font-weight: 500;"><xsl:sequence select="local:resolveData($dt//rng:data[1])"/></span>.                            
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:message select="'ERROR: Unable to resolve the following datatype on attribute ' || $current.att/@ident"/>
                            <xsl:message terminate="yes" select="$dt"/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:when test="$current.att/tei:datatype[rng:text]">
                    <xsl:variable name="dt" select="$current.att/tei:datatype" as="node()"/>
                    <xsl:choose>
                        <xsl:when test="count($dt/child::*) = 1 and $dt/rng:text and $dt/@maxOccurs = '1'">
                            Value is plain text.
                        </xsl:when>
                        <xsl:when test="count($dt/child::*) = 1 and $dt/rng:text and not($dt/@maxOccurs)">
                            Value is plain text.
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:message select="'ERROR: Unable to resolve the following datatype on attribute ' || $current.att/@ident"/>
                            <xsl:message terminate="no" select="$dt"/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:message select="'WARNING: Not sure how to resolve the values of attDef ' || $current.att/@ident"/>
                </xsl:otherwise>
            </xsl:choose>
            <span class="attributeClasses">
                <a class="link_odd" href="{$version}/attribute-classes/{lower-case(replace($current.class.id,':','---'))}.html"><xsl:value-of select="$current.class.id"/></a>
            </span>
        </div>
        
    </xsl:function>
    
    <xsl:function name="local:resolveData" as="node()+">
        <xsl:param name="data" as="node()"/>
        
        <xsl:choose>
            <xsl:when test="not($data/child::*)">
                <xsl:value-of select="$data/@type"/>
            </xsl:when>
            <xsl:when test="$data/@type = ('string','token') and $data/rng:param[@name = 'pattern']">
                a string matching the following regular expression: "<xsl:value-of select="$data/rng:param/text()"/>"
            </xsl:when>
            <xsl:when test="$data/@type = 'decimal' and $data/rng:param[@name = 'minInclusive'] and $data/rng:param[@name = 'maxInclusive']">
                a decimal number between <xsl:value-of select="$data/rng:param[@name = 'minInclusive']/text()"/> and <xsl:value-of select="$data/rng:param[@name = 'maxInclusive']/text()"/>
            </xsl:when>
            <xsl:when test="$data/@type = 'positiveInteger' and $data/rng:param[@name = 'minInclusive'] and $data/rng:param[@name = 'maxInclusive']">
                a positive integer between <xsl:value-of select="$data/rng:param[@name = 'minInclusive']/text()"/> and <xsl:value-of select="$data/rng:param[@name = 'maxInclusive']/text()"/>
            </xsl:when>
            <xsl:when test="$data/@type = 'positiveInteger' and $data/rng:param[@name = 'maxInclusive']">
                a positive integer no larger than <xsl:value-of select="$data/rng:param/text()"/>
            </xsl:when>
            <xsl:when test="$data/@type = 'nonNegativeInteger' and $data/rng:param[@name = 'maxInclusive']">
                a non-negative integer no larger than <xsl:value-of select="$data/rng:param/text()"/>
            </xsl:when>
            <xsl:when test="$data/@type = 'decimal' and $data/rng:param[@name = 'minInclusive']">
                a decimal number no smaller than <xsl:value-of select="$data/rng:param/text()"/>
            </xsl:when>
            <xsl:when test="$data/@type = 'decimal' and $data/rng:param[@name = 'minExclusive']">
                a decimal number larger than <xsl:value-of select="$data/rng:param/text()"/>
            </xsl:when>
            <xsl:when test="$data/@type = 'positiveInteger' and $data/rng:param[@name = 'pattern']">
                one of the following integers: <xsl:value-of select="string-join(tokenize($data/rng:param/text(),'|'),', ')"/>
            </xsl:when>
            <xsl:when test="$data/@type = 'decimal' and $data/rng:param[@name = 'pattern']">
                a decimal number matching the pattern "<xsl:value-of select="$data/rng:param/text()"/>"
            </xsl:when>
            <xsl:otherwise>
                <xsl:message select="'ERROR: Cannot resolve the following datatype:'"/>
                <xsl:message terminate="yes" select="$data"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>
    
    <xsl:function name="local:getParents" as="node()*">
        <xsl:param name="model.classes" as="node()*"/>
        
        <xsl:for-each select="$model.classes">
            <xsl:variable name="current.model" select="." as="node()"/>
            <xsl:variable name="relevant.elements" select="$mei.source//tei:elementSpec[(:.//tei:memberOf[@key = $current.model/@ident] or :).//tei:content//rng:ref[@name = $current.model/@ident]]" as="node()*"/>
            <!--<xsl:message select="'  INFO: looking for ' || count($relevant.elements) || ' elements in ' || $current.model/@ident"/>-->
            <xsl:sequence select="$relevant.elements"/>
            <xsl:variable name="inheriting.classes" select="$mei.source//tei:classSpec[@type = 'model' and @ident = $current.model//tei:memberOf/@key]" as="node()*"/>
            <xsl:sequence select="local:getParents($inheriting.classes)"/>
        </xsl:for-each>
    </xsl:function>
    
    <xsl:function name="local:getChilds" as="node()*">
        <xsl:param name="className" as="xs:string"/>
        <xsl:sequence select="$elements/descendant-or-self::tei:elementSpec[.//tei:memberOf[@key = $className]]"/>
        
        <xsl:variable name="inheriting.models" select="$model.classes/descendant-or-self::tei:classSpec[.//tei:memberOf/@key = $className]/@ident" as="xs:string*"/>
        <xsl:for-each select="$inheriting.models">
            <xsl:sequence select="local:getChilds(.)"/>    
        </xsl:for-each>
        
    </xsl:function>
    
    <!-- resolve model classes -->
    <xsl:template match="tei:classSpec[@type = 'model']">
        
        <xsl:variable name="classSpec" select="." as="node()"/>
        <div class="classSpec model">
            <h3 id="{@ident}"><xsl:value-of select="@ident"/></h3>
            <table class="wovenodd">
                <tr>
                    <td colspan="2" class="wovenodd-col2">
                        <xsl:value-of select="$classSpec/tei:desc/text()"/>
                    </td>
                </tr>
                <tr>
                    <td class="wovenodd-col1"><strong>Module</strong></td>
                    <td class="wovenodd-col2"><xsl:value-of select="$classSpec/@module"/></td>
                </tr>
                <tr>
                    <td class="wovenodd-col1"><strong>Available in</strong></td>
                    <td class="wovenodd-col2">
                        <div class="parent">
                            <xsl:variable name="direct.members" select="$classSpec/tei:classes/tei:memberOf[starts-with(@key,'model.')]" as="node()*"/>
                            <xsl:if test="count($direct.members) gt 0">
                                <div>
                                    <xsl:for-each select="$direct.members">
                                        <xsl:value-of select="if(position() gt 1) then(', ') else('')"/><a class="link_odd_classSpec" href="{$version}/model-classes/{@key}.html"><xsl:value-of select="@key"/></a>
                                    </xsl:for-each>
                                </div>
                            </xsl:if>
                            <xsl:variable name="referenced.members" select="$mei.source//tei:elementSpec[tei:content//rng:ref/@name = $classSpec/@ident]" as="node()*"/>
                            <xsl:if test="count($referenced.members) gt 0">
                                <div>
                                    <xsl:for-each select="$referenced.members">
                                        <xsl:value-of select="if(position() gt 1) then(', ') else('')"/><a class="link_odd_elementSpec" href="{$version}/elements/{@ident}.html"><xsl:value-of select="@ident"/></a>
                                    </xsl:for-each>
                                </div>
                            </xsl:if>
                        </div>
                    </td>
                </tr>
                <tr>
                    <td class="wovenodd-col1"><strong>Members</strong></td>
                    <td class="wovenodd-col2">
                        <div class="parent">
                            <xsl:variable name="direct.members" select="$mei.source//tei:elementSpec[.//tei:memberOf[@key = $classSpec/@ident]]" as="node()*"/>
                            <xsl:if test="count($direct.members) gt 0">
                                <div>
                                    <xsl:for-each select="$direct.members">
                                        <xsl:value-of select="if(position() gt 1) then(', ') else('')"/><a class="link_odd_elementSpec" href="{$version}/elements/{@ident}.html"><xsl:value-of select="@ident"/></a>
                                    </xsl:for-each>
                                    <xsl:choose>
                                        <xsl:when test="count($direct.members) = 0"/>
                                        <xsl:when test="count($direct.members) = 1">
                                            <xsl:value-of select="' (direct member of ' || $classSpec/@ident || ')'"/>
                                        </xsl:when>
                                        <xsl:otherwise>
                                            <xsl:value-of select="' (direct members of ' || $classSpec/@ident || ')'"/>
                                        </xsl:otherwise>
                                    </xsl:choose>
                                </div>
                            </xsl:if>
                            <xsl:for-each select="local:getElementsByModelClass($classSpec/@ident)">
                                <xsl:sequence select="."/>
                            </xsl:for-each>
                        </div>
                    </td>
                </tr>
                <xsl:if test="$classSpec/tei:classes">
                    <tr>
                        <td class="wovenodd-col1"><strong>Declaration</strong></td>
                        <td class="wovenodd-col2">
                            
                            <xsl:variable name="codeBlock">
                                <xsl:apply-templates select="$classSpec/tei:classes" mode="preserveSpace"><xsl:with-param name="getODD" tunnel="yes" select="true()"/></xsl:apply-templates>
                            </xsl:variable>
                            <div class="code" xml:space="preserve" data-lang="ODD"><code><xsl:apply-templates select="$codeBlock" mode="removeSpaceInCode"/></code></div>
                            
                            <!--<div xml:space="preserve" class="pre"><xsl:apply-templates select="$classSpec/tei:classes" mode="preserveSpace"><xsl:with-param name="getODD" tunnel="yes" select="true()"/></xsl:apply-templates></div>-->
                        </td>
                    </tr>
                </xsl:if>
                <xsl:if test="$classSpec/tei:remarks">
                    <tr>
                        <td class="wovenodd-col1"><strong>Remarks</strong></td>
                        <td class="wovenodd-col2">
                            <p><xsl:apply-templates select="$classSpec/tei:remarks/tei:p/node()"/></p>
                        </td>
                    </tr>
                </xsl:if>
                <xsl:for-each select="$classSpec//tei:constraintSpec">
                    <tr>
                        <td class="wovenodd-col1"><strong>Constraint</strong></td>
                        <td class="wovenodd-col2">
                            <div>
                                <xsl:for-each select=".//sch:assert">
                                    <div class="schematronText"><xsl:value-of select="normalize-space(.//text())"/></div>
                                </xsl:for-each>
                            </div>
                            <div class="code" xml:space="preserve" data-lang="Schematron"><code><xsl:apply-templates select=".//sch:rule" mode="preserveSpace"/></code></div>
                        </td>
                    </tr>
                </xsl:for-each>
            </table>
        </div>
    </xsl:template>
    
    <!-- resolve attribute classes -->
    <xsl:template match="tei:classSpec[@type = 'atts']">
        
        <xsl:variable name="classSpec" select="." as="node()"/>
        <div class="classSpec att">
            <h3 id="{@ident}"><xsl:value-of select="@ident"/></h3>
            <table class="wovenodd">
                <tr>
                    <td colspan="2" class="wovenodd-col2">
                        <xsl:value-of select="$classSpec/tei:desc/text()"/>
                    </td>
                </tr>
                <tr>
                    <td class="wovenodd-col1"><strong>Module</strong></td>
                    <td class="wovenodd-col2"><xsl:value-of select="$classSpec/@module"/></td>
                </tr>
                <tr>
                    <td class="wovenodd-col1"><strong>Members</strong></td>
                    <td class="wovenodd-col2">
                        <div class="parent">
                            <xsl:variable name="direct.members" select="$mei.source//tei:elementSpec[.//tei:memberOf[@key = $classSpec/@ident]]" as="node()*"/>
                            <xsl:if test="count($direct.members) gt 0">
                                <div>
                                    <xsl:for-each select="$direct.members">
                                        <xsl:value-of select="if(position() gt 1) then(', ') else('')"/><a class="link_odd_elementSpec" href="{$version}/elements/{@ident}.html"><xsl:value-of select="@ident"/></a>                                                
                                        
                                    </xsl:for-each>
                                    <xsl:choose>
                                        <xsl:when test="count($direct.members) = 0"/>
                                        <xsl:when test="count($direct.members) = 1">
                                            <xsl:value-of select="' (direct member of ' || $classSpec/@ident || ')'"/>
                                        </xsl:when>
                                        <xsl:otherwise>
                                            <xsl:value-of select="' (direct members of ' || $classSpec/@ident || ')'"/>
                                        </xsl:otherwise>
                                    </xsl:choose>
                                </div>
                            </xsl:if>
                            <xsl:for-each select="local:getElementsByAttClass($classSpec/@ident)">
                                <xsl:sequence select="."/>
                            </xsl:for-each>
                        </div>
                    </td>
                </tr>
                <tr>
                    <td class="wovenodd-col1"><strong>Attributes</strong></td>
                    <td class="wovenodd-col2">
                        
                        <!-- docu: identify all relevant attributes -->
                        <xsl:variable name="attributes" as="node()*">
                            
                            <!-- docu: get attributes specified at the current element -->
                            <xsl:for-each select="$classSpec//tei:attDef">
                                <xsl:variable name="current.att" select="." as="node()"/>
                                
                                <xsl:sequence select="local:resolveAttDef($current.att,$classSpec/@ident)"/>
                            </xsl:for-each>
                            <!-- get attributes derived from attribute classes -->
                            <xsl:sequence select="local:getAttributes($classSpec)"/>
                        </xsl:variable>
                        <xsl:variable name="attribute.names" select="distinct-values($attributes/descendant-or-self::span[@class = 'attribute']/string(text()))" as="xs:string*"/>
                        
                        <xsl:for-each select="$attribute.names">
                            <xsl:sort select="." data-type="text"/>
                            <xsl:variable name="current.att" select="." as="xs:string"/>
                            <xsl:if test="count($attributes/descendant-or-self::div[span[@class='attribute']/text() = $current.att]) gt 1">
                                <xsl:message select="'INFO: attribute ' || $current.att || ' specified multiple times on class ' || $classSpec/@ident"/>
                            </xsl:if>
                            <xsl:sequence select="($attributes/descendant-or-self::div[span[@class='attribute']/text() = $current.att])[1]"/>
                        </xsl:for-each>
                        
                    </td>
                </tr>
                <xsl:if test="$classSpec/tei:classes or $classSpec//tei:attDef">
                    <tr>
                        <td class="wovenodd-col1"><strong>Declaration</strong></td>
                        <td class="wovenodd-col2">
                            <xsl:if test="$classSpec/tei:classes">
                                <xsl:variable name="codeBlock">
                                    <xsl:apply-templates select="$classSpec/tei:classes" mode="preserveSpace"><xsl:with-param name="getODD" tunnel="yes" select="true()"/></xsl:apply-templates>
                                </xsl:variable>
                                <div class="code" xml:space="preserve" data-lang="ODD"><code><xsl:apply-templates select="$codeBlock" mode="removeSpaceInCode"/></code></div>
                                
                                <!--<div xml:space="preserve" class="pre"><xsl:apply-templates select="$classSpec/tei:classes" mode="preserveSpace"><xsl:with-param name="getODD" tunnel="yes" select="true()"/></xsl:apply-templates></div>-->    
                            </xsl:if>
                            <xsl:for-each select="$classSpec//tei:attDef">
                                <xsl:variable name="codeBlock">
                                    <xsl:apply-templates select="." mode="preserveSpace"><xsl:with-param name="getODD" tunnel="yes" select="true()"/></xsl:apply-templates>
                                </xsl:variable>
                                <div class="code" xml:space="preserve" data-lang="ODD"><code><xsl:apply-templates select="$codeBlock" mode="removeSpaceInCode"/></code></div>
                                
                                <!--<div xml:space="preserve" class="pre"><xsl:apply-templates select="." mode="preserveSpace"><xsl:with-param name="getODD" tunnel="yes" select="true()"/></xsl:apply-templates></div>-->
                            </xsl:for-each>
                        </td>
                    </tr>
                </xsl:if>
                <xsl:if test="$classSpec/tei:remarks">
                    <tr>
                        <td class="wovenodd-col1"><strong>Remarks</strong></td>
                        <td class="wovenodd-col2">
                            <p><xsl:apply-templates select="$classSpec/tei:remarks/tei:p/node()"/></p>
                        </td>
                    </tr>
                </xsl:if>
                <xsl:for-each select="$classSpec//tei:constraintSpec">
                    <tr>
                        <td class="wovenodd-col1"><strong>Constraint</strong></td>
                        <td class="wovenodd-col2">
                            <div>
                                <xsl:for-each select=".//sch:assert">
                                    <xsl:variable name="schematronText" as="xs:string*">
                                        <xsl:apply-templates select="child::node()" mode="getSchematronText"/>
                                    </xsl:variable>
                                    <div class="schematronText"><xsl:value-of select="normalize-space(string-join($schematronText,' '))"/></div>
                                </xsl:for-each>
                            </div>
                            <div class="code" xml:space="preserve" data-lang="Schematron"><code><xsl:apply-templates select=".//sch:rule" mode="preserveSpace"/></code></div>
                        </td>
                    </tr>
                </xsl:for-each>
            </table>
        </div>
    </xsl:template>
    
    <xsl:function name="local:getElementsByAttClass" as="node()*">
        <xsl:param name="att.class" as="xs:string"/>
                
        <xsl:variable name="inheriting.classes" select="$mei.source//tei:classSpec[@type = 'atts'][.//tei:memberOf/@key = $att.class]" as="node()*"/>
        <xsl:for-each select="$inheriting.classes">
            <xsl:variable name="current.class" select="." as="node()"/>
            <xsl:variable name="relevant.elements" select="$mei.source//tei:elementSpec[.//tei:memberOf[@key = $current.class/@ident] or .//tei:content//rng:ref[@name = $current.class/@ident]]" as="node()*"/>
            
            <xsl:choose>
                <xsl:when test="count($relevant.elements) gt 0">
                    <div>
                        <xsl:for-each select="$relevant.elements">
                            <xsl:value-of select="if(position() gt 1) then(', ') else('')"/><a class="link_odd_elementSpec" href="{$version}/elements/{@ident}.html"><xsl:value-of select="@ident"/></a>                                    
                                
                        </xsl:for-each>
                        <span> (via <a class="link_odd_classSpec" href="{$version}/attribute-classes/{$current.class/@ident}.html"><xsl:value-of select="$current.class/@ident"/></a>)</span>
                        
                    </div>
                </xsl:when>
                <xsl:otherwise>
                    <div>
                        <span><a class="link_odd_classSpec" href="{$version}/attribute-classes/{$current.class/@ident}"><xsl:value-of select="$current.class/@ident"/></a> (no elements directly inheriting from this class)</span>
                        
                    </div>
                </xsl:otherwise>
            </xsl:choose>
            
            <xsl:sequence select="local:getElementsByAttClass($current.class/@ident)"/>
        </xsl:for-each>
    </xsl:function>
    
    <xsl:function name="local:getElementsByModelClass" as="node()*">
        <xsl:param name="att.class" as="xs:string"/>
        
        <xsl:variable name="inheriting.classes" select="$mei.source//tei:classSpec[@type = 'model'][.//tei:memberOf/@key = $att.class]" as="node()*"/>
        <xsl:for-each select="$inheriting.classes">
            <xsl:variable name="current.class" select="." as="node()"/>
            <xsl:variable name="relevant.elements" select="$mei.source//tei:elementSpec[.//tei:memberOf[@key = $current.class/@ident] or .//tei:content//rng:ref[@name = $current.class/@ident]]" as="node()*"/>
            
            <xsl:choose>
                <xsl:when test="count($relevant.elements) gt 0">
                    <div>
                        <xsl:for-each select="$relevant.elements">
                            <xsl:value-of select="if(position() gt 1) then(', ') else('')"/><a class="link_odd_elementSpec" href="{$version}/model-classes/{@ident}.html"><xsl:value-of select="@ident"/></a>                                    
                            
                        </xsl:for-each>
                        <span> (via <a class="link_odd_classSpec" href="{$version}/model-classes/{$current.class/@ident}.html"><xsl:value-of select="$current.class/@ident"/></a>)</span>
                        
                    </div>
                </xsl:when>
                <xsl:otherwise>
                    <div>
                        <span><a class="link_odd_classSpec" href="{$version}/model-classes/{$current.class/@ident}.html"><xsl:value-of select="$current.class/@ident"/></a> (no elements directly inheriting from this class)</span>
                         
                    </div>
                </xsl:otherwise>
            </xsl:choose>
            
            <xsl:sequence select="local:getElementsByModelClass($current.class/@ident)"/>
        </xsl:for-each>
    </xsl:function>
    
    <!-- resolve data types -->
    <xsl:template match="tei:macroSpec">
        
        <xsl:variable name="macroSpec" select="." as="node()"/>
        <div class="macroSpec">
            <h3 id="{@ident}"><xsl:value-of select="@ident"/></h3>
            <table class="wovenodd">
                <tr>
                    <td colspan="2" class="wovenodd-col2">
                        <xsl:value-of select="$macroSpec/tei:desc/text()"/>
                    </td>
                </tr>
                <tr>
                    <td class="wovenodd-col1"><strong>Module</strong></td>
                    <td class="wovenodd-col2"><xsl:value-of select="$macroSpec/@module"/></td>
                </tr>
                <tr>
                    <td class="wovenodd-col1"><strong>Used by</strong></td>
                    <td class="wovenodd-col2">
                        <div class="parent">
                            
                            <xsl:variable name="dataTypes" select="$data.types/descendant-or-self::tei:macroSpec[.//tei:macroRef[@key = $macroSpec/@ident]]" as="node()*"/>
                            <xsl:variable name="attClasses" select="$att.classes/descendant-or-self::tei:classSpec[.//rng:ref[@name = $macroSpec/@ident]]" as="node()*"/>
                            <xsl:variable name="relevantElements" select="$elements/descendant-or-self::tei:elementSpec[.//rng:ref[@name = $macroSpec/@ident]]" as="node()*"/>
                            
                            <xsl:for-each select="($dataTypes | $attClasses | $relevantElements)">
                                <xsl:variable name="ref" select="." as="node()"/>
                                <xsl:if test="position() gt 1">
                                    <xsl:value-of select="', '"/>
                                </xsl:if>
                                <xsl:variable name="subref" select="$ref//tei:attDef[.//rng:ref[@name = $macroSpec/@ident]][1]/@ident" as="xs:string?"/>
                                <xsl:choose>
                                    <xsl:when test="local-name($ref) = 'macroSpec'">
                                        <a class="link_odd" href="{$version}/data-types/{$ref/@ident}.html"><xsl:value-of select="$ref/@ident"/></a>
                                    </xsl:when>
                                    <xsl:when test="local-name($ref) = 'classSpec' and $ref/@type = 'atts'">
                                        <a class="link_odd_classSpec" href="{$version}/attribute-classes/{$ref/@ident}.html"><xsl:value-of select="$ref/@ident"/></a><xsl:value-of select="if($subref) then(' (@' || $subref ||')') else()"/>
                                    </xsl:when>
                                    <xsl:when test="local-name($ref) = 'classSpec' and $ref/@type = 'model'">
                                        <a class="link_odd_classSpec" href="{$version}/model-classes/{$ref/@ident}.html"><xsl:value-of select="$ref/@ident"/></a><xsl:value-of select="if($subref) then(' (@' || $subref ||')') else()"/>
                                    </xsl:when>
                                    <xsl:when test="local-name($ref) = 'elementSpec'">
                                        <a class="link_odd_classSpec" href="{$version}/elements/{$ref/@ident}.html"><xsl:value-of select="$ref/@ident"/></a><xsl:value-of select="if($subref) then('/@' || $subref) else()"/>
                                    </xsl:when>
                                    <xsl:otherwise>
                                        <xsl:message terminate="no" select="'ERROR: Unable to resolve reference to ' || $macroSpec/@ident || ' from a ' || local-name($ref)"/>
                                    </xsl:otherwise>
                                </xsl:choose>
                            </xsl:for-each>
                        </div>
                    </td>
                </tr>
                <xsl:if test="$macroSpec//tei:valList">
                    <tr>
                        <td class="wovenodd-col1"><strong>Allowed values</strong></td>
                        <td class="wovenodd-col2">
                            <dl>
                                <xsl:for-each select="$macroSpec//tei:valList/tei:valItem">
                                    <dt><xsl:value-of select="@ident"/></dt><dd><xsl:value-of select="tei:desc/text()"/></dd>
                                </xsl:for-each>
                            </dl>
                        </td>
                    </tr>
                </xsl:if>
                <xsl:if test="$macroSpec/tei:content">
                    <tr>
                        <td class="wovenodd-col1"><strong>Declaration</strong></td>
                        <td class="wovenodd-col2">
                            
                            <xsl:variable name="codeBlock">
                                <xsl:apply-templates select="$macroSpec/tei:content" mode="preserveSpace"><xsl:with-param name="getODD" tunnel="yes" select="true()"/></xsl:apply-templates>
                            </xsl:variable>
                            <div class="code" xml:space="preserve" data-lang="ODD"><code><xsl:apply-templates select="$codeBlock" mode="removeSpaceInCode"/></code></div>
                            
                            <!--<div xml:space="preserve" class="pre"><xsl:apply-templates select="$macroSpec/tei:content" mode="preserveSpace"><xsl:with-param name="getODD" tunnel="yes" select="true()"/></xsl:apply-templates></div>-->
                        </td>
                    </tr>    
                </xsl:if>
                <xsl:if test="$macroSpec/tei:remarks">
                    <tr>
                        <td class="wovenodd-col1"><strong>Remarks</strong></td>
                        <td class="wovenodd-col2">
                            <p><xsl:apply-templates select="$macroSpec/tei:remarks/tei:p/node()"/></p>
                        </td>
                    </tr>
                </xsl:if>
                <xsl:for-each select="$macroSpec//tei:constraintSpec">
                    <tr>
                        <td class="wovenodd-col1"><strong>Constraint</strong></td>
                        <td class="wovenodd-col2">
                            <div>
                                <xsl:for-each select=".//sch:assert">
                                    <div class="schematronText"><xsl:value-of select="normalize-space(string-join(.//text(),' '))"/></div>
                                </xsl:for-each>
                            </div>
                            <div class="code" xml:space="preserve" data-lang="Schematron"><code><xsl:apply-templates select=".//sch:rule" mode="preserveSpace"/></code></div>
                        </td>
                    </tr>
                </xsl:for-each>
            </table>
        </div>
    </xsl:template>
    
    <xsl:template match="tei:content" mode="parseMacroSpec">
        <xsl:apply-templates select="." mode="preserveSpace">
            <xsl:with-param name="getODD" tunnel="yes" select="true()"/>
        </xsl:apply-templates>
        <!-- zeroOrMore -->
        <!-- optional -->
        <!-- empty -->
        <!-- element -->
        <!-- data -->
        <!-- choice -->
        <!-- alternate -->
        
        <!-- valList -->
    </xsl:template>
    
    <xsl:template match="text()" mode="getSchematronText" priority="1">
        <xsl:next-match/>
    </xsl:template>
    
    <xsl:template match="sch:value-of" mode="getSchematronText">
        <xsl:value-of select="string(@select)"/>
    </xsl:template>
    
    <!-- generic templates -->
    
    <xsl:template match="tei:*" mode="#all">
        <!--<xsl:message select="'DEBUG: processing tei:' || local-name()"/>-->
        <span class="{local-name()}">
            <xsl:apply-templates select="node()" mode="#current"/>
        </span>
    </xsl:template>
    
    <xsl:template match="rng:*" mode="#all">
        <!--<xsl:message select="'DEBUG: processing tei:' || local-name()"/>-->
        <span class="{local-name()}">
            <xsl:apply-templates select="node()" mode="#current"/>
        </span>
    </xsl:template>
    
    
    <xsl:template match="egx:egXML" mode="preserveSpace" priority="5">
        <xsl:copy-of select="node()"/>
    </xsl:template>
    
    <!-- in order to preserve spacing, it is important that the following template is kept on one line -->
    <xsl:template match="element()" mode="preserveSpace" priority="1">
        <xsl:param name="indent" as="xs:integer?"/>
        <xsl:variable name="indent.level" select="if($indent) then($indent) else(1)" as="xs:integer"/>
        <xsl:variable name="element" select="." as="node()"/>
        <xsl:choose>
            <xsl:when test="local-name() = 'param' and @name = 'pattern' and string-length(text()) gt 30">
                <div class="indent{$indent.level} indent"><span data-indentation="{$indent.level}" class="element">&lt;<xsl:value-of select="name($element)"/><xsl:apply-templates select="$element/@*" mode="#current"/>&gt;</span>
                    <xsl:choose>
                        <xsl:when test="string-length(text()) gt 240">
                            <div class="indent{$indent.level + 1} indent"><xsl:value-of select="substring(text(),1,60)"/></div>
                            <div class="indent{$indent.level + 2} dblIndent"><xsl:value-of select="substring(text(),61,60)"/></div>
                            <div class="indent{$indent.level + 2} dblIndent"><xsl:value-of select="substring(text(),121,60)"/></div>
                            <div class="indent{$indent.level + 2} dblIndent"><xsl:value-of select="substring(text(),181,60)"/></div>
                            <div class="indent{$indent.level + 2} dblIndent"><xsl:value-of select="substring(text(),241,60)"/></div>
                        </xsl:when>
                        <xsl:when test="string-length(text()) gt 180">
                            <div class="indent{$indent.level + 1} indent"><xsl:value-of select="substring(text(),1,60)"/></div>
                            <div class="indent{$indent.level + 2} dblIndent"><xsl:value-of select="substring(text(),61,60)"/></div>
                            <div class="indent{$indent.level + 2} dblIndent"><xsl:value-of select="substring(text(),121,60)"/></div>
                            <div class="indent{$indent.level + 2} dblIndent"><xsl:value-of select="substring(text(),181,60)"/></div>
                        </xsl:when>
                        <xsl:when test="string-length(text()) gt 120">
                            <div class="indent{$indent.level + 1} indent"><xsl:value-of select="substring(text(),1,60)"/></div>
                            <div class="indent{$indent.level + 2} dblIndent"><xsl:value-of select="substring(text(),61,60)"/></div>
                            <div class="indent{$indent.level + 2} dblIndent"><xsl:value-of select="substring(text(),121,60)"/></div>
                        </xsl:when>
                        <xsl:when test="string-length(text()) gt 60">
                            <div class="indent{$indent.level + 1} indent"><xsl:value-of select="substring(text(),1,60)"/></div>
                            <div class="indent{$indent.level + 2} dblIndent"><xsl:value-of select="substring(text(),61,60)"/></div>
                        </xsl:when>
                        <xsl:when test="string-length(text()) gt 30">
                            <div class="indent{$indent.level + 1} indent"><xsl:value-of select="substring(text(),1,100)"/></div>        
                        </xsl:when>
                    </xsl:choose>
                <span data-indentation="{$indent.level}" class="element">&lt;/<xsl:value-of select="name($element)"/>&gt;</span></div>
            </xsl:when>
            <xsl:otherwise>
                <div class="indent{$indent.level} indent"><span data-indentation="{$indent.level}" class="element">&lt;<xsl:value-of select="name($element)"/><xsl:apply-templates select="$element/@*" mode="#current"/><xsl:if test="not($element/node())">/</xsl:if>&gt;</span><xsl:apply-templates select="$element/node()" mode="#current"><xsl:with-param name="indent" select="$indent.level + 1" as="xs:integer"/></xsl:apply-templates><xsl:if test="$element/node()"><span data-indentation="{$indent.level}" class="element">&lt;/<xsl:value-of select="name($element)"/>&gt;</span></xsl:if></div>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    
    <!-- in order to preserve spacing, it is important that the following template is kept on one line -->
    <xsl:template match="comment()" mode="preserveSpace" priority="1">
        <xsl:param name="indent" as="xs:integer?"/>
        <xsl:variable name="indent.level" select="if($indent) then($indent) else(1)" as="xs:integer"/>
        <xsl:variable name="element" select="." as="node()"/>
        <div class="indent{$indent.level} indent"><span data-indentation="{$indent.level}" class="comment">&lt;!--<xsl:value-of select="."/>--&gt;</span></div>   
    </xsl:template>
    
    <!-- in order to preserve spacing, it is important that the following template is kept on one line -->
    <xsl:template match="@*" mode="preserveSpace" priority="1"><xsl:value-of select="' '"/><span class="attribute"><xsl:value-of select="name()"/>=</span><span class="attributevalue">"<xsl:value-of select="string(.)"/>"</span></xsl:template>
    
    <!-- in order to preserve spacing, it is important that the following template is kept on one line -->
    <xsl:template match="tei:memberOf/@key" mode="preserveSpace" priority="2" xml:space="preserve">
        <xsl:choose>
            <xsl:when test="starts-with(string(.),'att.')"><xsl:value-of select="' '"/><span class="attribute"><xsl:value-of select="local-name()"/>=<span class="attributevalue">"<a class="link_odd" href="{$version}/attribute-classes/{string(.)}.html"><xsl:value-of select="normalize-space(string(.))"/></a>"</span></span></xsl:when>
            <xsl:when test="starts-with(string(.),'model.')"><xsl:value-of select="' '"/><span class="attribute"><xsl:value-of select="local-name()"/>=<span class="attributevalue">"<a class="link_odd" href="{$version}/model-classes/{string(.)}.html"><xsl:value-of select="string(.)"/></a>"</span></span></xsl:when>
            <xsl:otherwise><xsl:message terminate="yes" select="'Dunno how to resolve memberOf reference ' || ."/></xsl:otherwise>
        </xsl:choose></xsl:template>
    
    <!-- in order to preserve spacing, it is important that the following template is kept on one line -->
    <xsl:template match="tei:macroRef/@key" mode="preserveSpace" priority="2" xml:space="preserve"><xsl:value-of select="' '"/><span class="attribute"><xsl:value-of select="local-name()"/>=<span class="attributevalue">"<a class="link_odd" href="{$version}/data-types/{string(.)}.html"><xsl:value-of select="string(.)"/></a>"</span></span></xsl:template>
    
    <!-- in order to preserve spacing, it is important that the following template is kept on one line -->
    <xsl:template match="rng:ref/@name" mode="preserveSpace" priority="2" xml:space="preserve">
        <xsl:variable name="target.type" as="xs:string"><xsl:choose>
                <xsl:when test="starts-with(.,'model.')"><xsl:value-of select="'model'"/></xsl:when>
                <xsl:when test="starts-with(.,'macro.')"><xsl:value-of select="'macro'"/></xsl:when>
                <xsl:when test="starts-with(.,'data.')"><xsl:value-of select="'macro'"/></xsl:when>
                <xsl:when test=". = $mei.source//tei:elementSpec/@ident"><xsl:value-of select="'element'"/></xsl:when>
                <xsl:otherwise><xsl:value-of select="'other'"/></xsl:otherwise>
            </xsl:choose></xsl:variable>
        <xsl:choose>
            <xsl:when test="$target.type = 'element'"><xsl:value-of select="' '"/><span class="attribute"><xsl:value-of select="local-name()"/>=<span class="attributevalue">"<a class="link_odd" href="{$version}/elements/{string(.)}.html"><xsl:value-of select="string(.)"/></a>"</span></span></xsl:when>
            <xsl:when test="$target.type = 'model'"><xsl:value-of select="' '"/><span class="attribute"><xsl:value-of select="local-name()"/>=<span class="attributevalue">"<a class="link_odd" href="{$version}/model-classes/{string(.)}.html"><xsl:value-of select="string(.)"/></a>"</span></span></xsl:when>
            <xsl:when test="$target.type = 'macro'"><xsl:value-of select="' '"/><span class="attribute"><xsl:value-of select="local-name()"/>=<span class="attributevalue">"<a class="link_odd" href="{$version}/data-types/{string(.)}.html"><xsl:value-of select="string(.)"/></a>"</span></span></xsl:when>
            <xsl:when test="$target.type = 'other'"><xsl:value-of select="' '"/><span class="attribute"><xsl:value-of select="local-name()"/>=<span class="attributevalue">"<xsl:value-of select="string(.)"/>"</span></span></xsl:when>
        </xsl:choose>
    </xsl:template>
        
     <xsl:template match="@mode[not(ancestor::egx:egXML)]" mode="preserveSpace" priority="2">
        <xsl:param name="getODD" tunnel="yes" as="xs:boolean?"/>
        <!--<xsl:if test="not($getODD) or $getODD = false()">
            <xsl:next-match/>
        </xsl:if>-->
    </xsl:template>
    
    <!-- remove attributes for elementSpec's ODD -->
    <xsl:template match="tei:elementSpec//@ns | tei:elementSpec//@predeclare | tei:elementSpec//@status | tei:elementSpec//@autoPrefix" mode="preserveSpace" priority="2">
        <xsl:param name="getODD" tunnel="yes" as="xs:boolean?"/>
        <!--<xsl:if test="not($getODD) or $getODD = false()">
            <xsl:next-match/>
        </xsl:if>-->
    </xsl:template>
    
    <!-- remove attributes for classSpec's ODD -->
    <xsl:template match="tei:classSpec//@ns | tei:classSpec//@predeclare | tei:classSpec//@status | tei:classSpec//@autoPrefix" mode="preserveSpace" priority="2">
        <xsl:param name="getODD" tunnel="yes" as="xs:boolean?"/>
        <!--<xsl:if test="not($getODD) or $getODD = false()">
            <xsl:next-match/>
        </xsl:if>-->
    </xsl:template>
    
    <!-- remove attributes for macroSpec's ODD -->
    <xsl:template match="tei:macroSpec//@ns | tei:macroSpec//@predeclare | tei:macroSpec//@status | tei:macroSpec//@autoPrefix" mode="preserveSpace" priority="2">
        <xsl:param name="getODD" tunnel="yes" as="xs:boolean?"/>
        <!--<xsl:if test="not($getODD) or $getODD = false()">
            <xsl:next-match/>
        </xsl:if>-->
    </xsl:template>
    
    <!-- the following templates are used to support the unicode "reverse solidus overlay" character (u20E5) -->
    <xsl:template match="tei:p[following-sibling::*[1][local-name() = 'figure'][child::tei:graphic/@url = 'Images/modules/harmony/figuredBass05.png']]/text()" priority="1">
        <xsl:choose>
            <xsl:when test="contains(.,'⃥')">
                <xsl:value-of select="substring-before(.,'⃥')"/><span class="reverseSolidus">⃥</span><xsl:value-of select="substring-after(.,'⃥')"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:next-match/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="*:egXML/*:harm/*:fb/*:f/text()" mode="#all" priority="1">
        <xsl:choose>
            <xsl:when test="contains(.,'⃥')">
                <xsl:value-of select="substring-before(.,'⃥')"/><span class="reverseSolidus">⃥</span><xsl:value-of select="substring-after(.,'⃥')"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:next-match/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    
    <xd:doc scope="component">
        <xd:desc>
            <xd:p>
                The following template provides the general frame for a complete HTML file with all contents
            </xd:p>
        </xd:desc>
    </xd:doc>
    <xsl:template name="getSinglePage">
        <xsl:param name="contents" as="node()*"/>
        
        <html xml:lang="en">
            <head>
                <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
                <xsl:comment>THIS FILE IS GENERATED FROM AN XML MASTER. DO NOT EDIT!</xsl:comment>
                <title>Music Encoding Initiative Guidelines</title>
                <meta name="author" content="Perry D. Roland, Johannes Kepper" />
                <meta name="subject" content="Documentation for the Music Encoding Initiative (MEI) Data Model" />
                <meta name="keywords" content="Music Encoding, MEI, Digital Humanities, Music, Musicology, Music Librarianship, Music Information Retrieval" />
                <meta name="date" content="{substring(string(current-date()),1,10)}" />
                <meta name="generator" content="MEI XSLT stylesheets" />
                <meta name="DC.Title" content="Music Encoding Initiative Guidelines" />
                <meta name="DC.Type" content="Text" />
                <meta name="DC.Format" content="text/html" />
                <link rel="stylesheet" media="print" type="text/css"
                    href="css/mei-print.css" />
                <link href="css/mei.css" media="print" rel="stylesheet"
                    type="text/css" />
                
            </head>
            <body class="simple" id="TOP">
                <section id="dataStore" style="display: none;">
                    <div id="versionInfo" data-version="{$version}"/>
                    <div id="roleInfo">
                        <xsl:choose>
                            <xsl:when test="$role = 'release'"> Release <xsl:value-of select="$version"/></xsl:when>
                            <xsl:when test="$role = 'dev'">(latest development revision, PDF generated on <xsl:value-of select="substring(string(current-date()),1,10)"/>)</xsl:when>
                            <xsl:when test="$role = 'custom'">(customization, based on <xsl:value-of select="$version"/>, PDF generated on <xsl:value-of select="substring(string(current-date()),1,10)"/>)</xsl:when>
                        </xsl:choose>
                    </div>
                </section>
                <div class="titlePage">
                    <div class="docTitle">
                        <div class="titlePart">
                            Music Encoding Initiative Guidelines
                        </div>
                        <xsl:choose>
                            <xsl:when test="$role = 'release'">
                                <div class="versionInfo">Version <xsl:value-of select="$version"/></div>
                            </xsl:when>
                            <xsl:when test="$role = 'dev'">
                                <div class="versionInfo">Latest development revision, based on Version <xsl:value-of select="$version"/></div>
                            </xsl:when>
                            <xsl:when test="$role = 'custom'">
                                <div class="versionInfo">Customization, based on Version <xsl:value-of select="$version"/></div>
                            </xsl:when>
                        </xsl:choose>
                        
                    </div>
                    <div class="byline">
                        <xsl:choose>
                            <xsl:when test="$role = 'release'">
                                Prepared and maintained by the Music Encoding Initiative Board        
                            </xsl:when>
                            <xsl:when test="$role = 'dev'">
                                Developed by the Music Encoding Initiative Technical Team        
                            </xsl:when>
                            <xsl:when test="$role = 'custom'">
                                        
                            </xsl:when>
                        </xsl:choose>
                    </div>
                    <div class="figure meiLogo">
                        <img src="Images/meilogo.png" alt="" class="graphic" />
                    </div>
                    <div class="byline editors">
                        <xsl:choose>
                            <xsl:when test="$role = 'custom'">
                                Based on original work edited by Perry Roland and Johannes Kepper<br />
                                <br />
                                With contributions by Benjamin Bohl, Andrew Hankinson, Maja Hartwig, Zoltán Kömíves, Laurent Pugin,<br /> 
                                Kristina Richts, Axel Teich Geertinger, Raffaele Viglianti, and Thomas Weber 
                            </xsl:when>
                            <xsl:otherwise>
                                Edited by Perry Roland and Johannes Kepper<br />
                                <br />
                                With contributions by Benjamin Bohl, Andrew Hankinson, Maja Hartwig, Zoltán Kömíves, Laurent Pugin,<br /> 
                                Kristina Richts, Axel Teich Geertinger, Raffaele Viglianti, and Thomas Weber      
                            </xsl:otherwise>
                        </xsl:choose>
                    </div>
                    <div class="docImprint beginPages">
                        <xsl:choose>
                            <xsl:when test="$role = 'custom'">
                                <div class="copyright">© for original Guidelines by the Music Encoding Initiative (MEI) Board.</div>
                            </xsl:when>
                            <xsl:otherwise>
                                <div class="copyright">© by the Music Encoding Initiative (MEI) Board.</div>
                            </xsl:otherwise>
                        </xsl:choose>
                        <div>
                            <span class="pubPlace">Charlottesville and Detmold</span>.
                            <span class="docDate"><xsl:value-of select="$imprint.date"/></span>
                        </div>
                        <div class="license">
                            Licensed under the Educational Community License, Version 2.0 (the "License"); you
                            may not use this file except in compliance with the License. You may obtain a copy
                            of the License at <a class="link_ref" href="http://opensource.org/licenses/ECL-2.0">http://opensource.org/licenses/ECL-2.0</a>.
                        </div>
                    </div>
                </div>
                
                <!-- toc -->
                <div class="teidiv0 alsoBegin" id="toc">
                    <div class="tei_toc">
                        <h2>Table of contents</h2>
                        <xsl:if test="$role = ('release','dev')">
                            <ul class="toc toc_front">
                                <xsl:for-each select="$mei.source//tei:front/tei:div[not(./tei:divGen[@type = 'toc'])]">
                                    <li class="toc">
                                        <a class="toc toc_0" href="#frontChapter_{position()}"><xsl:value-of select="child::tei:head[1]/text()"/></a>
                                    </li>
                                </xsl:for-each>
                            </ul>
                            <ul class="toc toc_body">
                                <!-- this generates the table of contents. avoiding recursion for clarity -->
                                <xsl:for-each select="$all.chapters/*[@level = '1']">
                                    <xsl:variable name="tocInfo.1" select="." as="node()"/>
                                    <li class="toc">
                                        <span class="headingNumber"><xsl:value-of select="$tocInfo.1/@number"/>. </span>
                                        <a class="toc toc_0" href="#{$tocInfo.1/@xml:id}" title="{$tocInfo.1/@head}"><xsl:value-of select="$tocInfo.1/@head"/></a>
                                        <xsl:if test="$tocInfo.1/following-sibling::*[@parent.id = $tocInfo.1/@xml:id]">
                                            <ul class="toc">
                                                <xsl:for-each select="$tocInfo.1/following-sibling::*[@parent.id = $tocInfo.1/@xml:id]">
                                                    
                                                    <xsl:variable name="tocInfo.2" select="." as="node()"/>
                                                    <li class="toc">
                                                        <span class="headingNumber"><xsl:value-of select="$tocInfo.2/@number"/>. </span>
                                                        <a class="toc toc_1" href="#{$tocInfo.2/@xml:id}" title="{$tocInfo.2/@head}"><xsl:value-of select="$tocInfo.2/@head"/></a>
                                                        <xsl:if test="$tocInfo.2/following-sibling::*[@parent.id = $tocInfo.2/@xml:id]">
                                                            <ul class="toc">
                                                                <xsl:for-each select="$tocInfo.1/following-sibling::*[@parent.id = $tocInfo.2/@xml:id]">
                                                                    
                                                                    <xsl:variable name="tocInfo.3" select="." as="node()"/>
                                                                    <li class="toc">
                                                                        <span class="headingNumber"><xsl:value-of select="$tocInfo.3/@number"/>. </span>
                                                                        <a class="toc toc_2" href="#{$tocInfo.3/@xml:id}" title="{$tocInfo.3/@head}"><xsl:value-of select="$tocInfo.3/@head"/></a>
                                                                        <xsl:if test="$tocInfo.3/following-sibling::*[@parent.id = $tocInfo.3/@xml:id]">
                                                                            <ul class="toc">
                                                                                <xsl:for-each select="$tocInfo.3/following-sibling::*[@parent.id = $tocInfo.3/@xml:id]">
                                                                                    
                                                                                    <xsl:variable name="tocInfo.4" select="." as="node()"/>
                                                                                    <li class="toc">
                                                                                        <span class="headingNumber"><xsl:value-of select="$tocInfo.4/@number"/>. </span>
                                                                                        <a class="toc toc_3" href="#{$tocInfo.4/@xml:id}" title="{$tocInfo.4/@head}"><xsl:value-of select="$tocInfo.4/@head"/></a>
                                                                                        <xsl:if test="$tocInfo.4/following-sibling::*[@parent.id = $tocInfo.4/@xml:id]">
                                                                                            <ul class="toc">
                                                                                                <xsl:for-each select="$tocInfo.4/following-sibling::*[@parent.id = $tocInfo.4/@xml:id]">
                                                                                                    
                                                                                                    <xsl:variable name="tocInfo.5" select="." as="node()"/>
                                                                                                    <li class="toc">
                                                                                                        <span class="headingNumber"><xsl:value-of select="$tocInfo.5/@number"/>. </span>
                                                                                                        <a class="toc toc_4" href="#{$tocInfo.5/@xml:id}" title="{$tocInfo.5/@head}"><xsl:value-of select="$tocInfo.5/@head"/></a>
                                                                                                    </li>
                                                                                                    
                                                                                                </xsl:for-each>
                                                                                            </ul>
                                                                                        </xsl:if>
                                                                                    </li>
                                                                                    
                                                                                </xsl:for-each>
                                                                            </ul>
                                                                        </xsl:if>
                                                                    </li>
                                                                    
                                                                </xsl:for-each>
                                                            </ul>
                                                        </xsl:if>
                                                    </li>
                                                    
                                                </xsl:for-each>
                                            </ul>
                                        </xsl:if>
                                    </li>
                                </xsl:for-each>
                            </ul>
                        </xsl:if>
                        
                        <ul class="toc toc_back">
                            <li class="toc">
                                
                                <a class="toc toc_0" href="#appendix">MEI Data Dictionary</a>        
                                    
                                <ul class="toc">
                                    
                                    <xsl:for-each select="$mei.source//tei:back/tei:div[@xml:id='DataDictConv']">
                                        <li class="toc">
                                            <a class="toc toc_1" href="#{@xml:id}"><xsl:value-of select="child::tei:head[1]/text()"/></a>
                                            <xsl:if test="child::tei:div">
                                                <ul class="toc">
                                                    <xsl:for-each select="child::tei:div">
                                                        <li class="toc">
                                                            <a class="toc toc_2" href="#{@xml:id}"><xsl:value-of select="child::tei:head[1]/text()"/></a>
                                                            <xsl:if test="child::tei:div">
                                                                <ul class="toc">
                                                                    <xsl:for-each select="child::tei:div">
                                                                        <li class="toc">
                                                                            <a class="toc toc_3" href="#{@xml:id}"><xsl:value-of select="child::tei:head[1]/text()"/></a>
                                                                        </li>
                                                                    </xsl:for-each> 
                                                                </ul>
                                                            </xsl:if>
                                                        </li>
                                                    </xsl:for-each> 
                                                </ul>
                                            </xsl:if>
                                        </li>
                                        
                                    </xsl:for-each>
                                    
                                    <li class="toc">
                                        <a class="toc toc_1" href="#appendix_Elements">Elements</a>
                                    </li>
                                    <li class="toc">
                                        <a class="toc toc_1" href="#appendix_Models">Model Classes</a>
                                    </li>
                                    <li class="toc">
                                        <a class="toc toc_1" href="#appendix_Atts">Attribute Classes</a>
                                    </li>
                                    <li class="toc">
                                        <a class="toc toc_1" href="#appendix_DataMacros">Datatypes and Macros</a>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                </div>
                
                <xsl:if test="not($role = 'custom')">
                    <!-- Preface, Acknowledgements and Introduction -->
                    <xsl:for-each select="$mei.source//tei:front/tei:div[not(./tei:divGen[@type = 'toc'])]">
                        <div class="teidiv0 alsoBegin" id="frontChapter_{position()}">
                            <xsl:apply-templates select="node()"/>
                        </div>
                    </xsl:for-each>
                </xsl:if>
                
                <!-- chapters go here -->
                <div class="regularPage">
                    
                    <xsl:if test="not($role = 'custom')">
                        <xsl:sequence select="$contents[local-name() = 'section']"/>
                    </xsl:if>
                    
                    <section id="tei_back">
                        <h1 id="appendix">MEI Data Dictionary</h1>
                        <div>
                            <xsl:apply-templates select="$mei.source//tei:back/tei:div[@xml:id='DataDictConv']"/>
                        </div>
                        <div>
                            <h2 id="appendix_Elements"><span class="headingNumber"/><span class="head">Elements</span></h2>
                            <xsl:sequence select="$contents[local-name() = 'div' and @class='elementSpec']"/>
                        </div>
                        <div>
                            <h2 id="appendix_Models"><span class="headingNumber"/><span class="head">Model Classes</span></h2>
                            <xsl:sequence select="$contents[local-name() = 'div' and @class='classSpec model']"/>
                        </div>
                        <div>
                            <h2 id="appendix_Atts"><span class="headingNumber"/><span class="head">Attribute Classes</span></h2>
                            <xsl:sequence select="$contents[local-name() = 'div' and @class='classSpec att']"/>
                        </div>
                        <div>
                            <h2 id="appendix_DataMacros"><span class="headingNumber"/><span class="head">Datatypes and Macros</span></h2>
                            <xsl:sequence select="$contents[local-name() = 'div' and @class='macroSpec']"/>
                        </div>
                    </section>
                </div>
            </body>
        </html>
    </xsl:template>
    
    <xsl:template name="linkToElement">
        <xsl:param name="elem" as="xs:string"/>
        <xsl:value-of select="$version || '/elements/' || lower-case($elem) || '.html'"/>
    </xsl:template>
    
    <xsl:template name="linkToChapter">
        <xsl:param name="chapter" as="xs:string"/>
        <xsl:value-of select="$version || '/guidelines/' || lower-case($chapter) || '.html'"/>
    </xsl:template>
    
    <xsl:template name="linkToAttribute">
        <xsl:param name="att" as="xs:string"/>
        <xsl:value-of select="$version || '/attribute-classes/' || lower-case($att) || '.html'"/>
    </xsl:template>
    
    <xsl:template name="linkToModel">
        <xsl:param name="model" as="xs:string"/>
        <xsl:value-of select="$version || '/model-classes/' || lower-case($model) || '.html'"/>
    </xsl:template>
    
    <xsl:template name="linkToData">
        <xsl:param name="data" as="xs:string"/>
        <xsl:value-of select="$version || '/data-types/' || lower-case($data) || '.html'"/>
    </xsl:template>
    
    <xsl:template match="text()" mode="cleanup.example" priority="1"><xsl:value-of select="normalize-space(.)"/></xsl:template>
    
    <xsl:function name="local:padNumber2" as="xs:string">
        <xsl:param name="number" as="xs:string"/>
        <xsl:choose>
            <xsl:when test="string-length($number) = 1">
                <xsl:value-of select="'0' || $number"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$number"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>
    
    <xsl:template match="node() | @*" mode="#all">
        <xsl:copy>
            <xsl:apply-templates select="node() | @*" mode="#current"/>
        </xsl:copy>
    </xsl:template>
    
</xsl:stylesheet>